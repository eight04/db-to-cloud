{"version":3,"file":"db-to-cloud.min.js","sources":["../node_modules/@eight04/read-write-lock/index.js","../lib/db-to-cloud.js","../node_modules/universal-base64/dist/browser.js","../lib/request.js","../shim/path.js","../lib/drive/webdav.js","../lib/drive/github.js","../lib/drive/dropbox.js","../lib/drive/onedrive.js","../lib/drive/google.js"],"sourcesContent":["function createLock({maxActiveReader = Infinity} = {}) {\r\n  let firstTask;\r\n  let lastTask;\r\n  let activeReader = 0;\r\n  const self = {\r\n    read: fn => que(fn, false),\r\n    write: fn => que(fn, true),\r\n    length: 0\r\n  };\r\n  return self;\r\n  \r\n  function que(fn, block) {\r\n    const task = createTask({fn, block});\r\n    if (!lastTask) {\r\n      firstTask = lastTask = task;\r\n    } else {\r\n      lastTask.next = task;\r\n      task.prev = lastTask;\r\n      lastTask = task;\r\n      if (!firstTask) {\r\n        firstTask = lastTask;\r\n      }\r\n    }\r\n    self.length++;\r\n    deque();\r\n    return task.q.promise;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n  \r\n  function createTask({\r\n    fn,\r\n    block = false,\r\n    prev,\r\n    next,\r\n    q = defer(),\r\n    q2 = fn.length ? defer() : null\r\n  }) {\r\n    return {fn, block, prev, next, q, q2};\r\n  }\r\n  \r\n  function deque() {\r\n    const task = firstTask;\r\n    if (\r\n      !task ||\r\n      task.block && task.prev ||\r\n      task.prev && task.prev.block ||\r\n      activeReader >= maxActiveReader\r\n    ) {\r\n      return;\r\n    }\r\n    if (!task.block) {\r\n      activeReader++;\r\n    }\r\n    firstTask = task.next;\r\n    let result;\r\n    try {\r\n      result = task.fn(task.q2 && task.q2.resolve);\r\n    } catch (err) {\r\n      task.q.reject(err);\r\n      // auto release with sync error\r\n      // q2 is useless in this case\r\n      onDone();\r\n      return;\r\n    }\r\n    if (task.q2) {\r\n      task.q2.promise.then(_onDone);\r\n    }\r\n    if (result && result.then) {\r\n      const pending = result.then(task.q.resolve, task.q.reject);\r\n      if (!task.q2) {\r\n        pending.then(onDone);\r\n      }\r\n    } else {\r\n      task.q.resolve(result);\r\n      if (!task.q2) {\r\n        // it's a sync function and you don't want to release it manually, why\r\n        // do you need a lock?\r\n        onDone();\r\n        return;\r\n      }\r\n    }\r\n    deque();\r\n    \r\n    function onDone() {\r\n      _onDone();\r\n    }\r\n    \r\n    function _onDone(afterDone) {\r\n      if (task.prev) {\r\n        task.prev.next = task.next;\r\n      }\r\n      if (task.next) {\r\n        task.next.prev = task.prev;\r\n      }\r\n      if (lastTask === task) {\r\n        lastTask = task.prev;\r\n      }\r\n      if (!task.block) {\r\n        activeReader--;\r\n      }\r\n      self.length--;\r\n      if (afterDone) {\r\n        afterDone();\r\n      }\r\n      deque();\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLockPool(options) {\r\n  const locks = new Map; // scope -> lock\r\n  return {\r\n    read: (scope, fn) => op(scope, fn, \"read\"),\r\n    write: (scope, fn) => op(scope, fn, \"write\"),\r\n    locks\r\n  };\r\n  \r\n  async function op(scopeIter, fn, opType) {\r\n    // FIXME: dead lock if there are duplicated scopes?\r\n    const scopes = [];\r\n    const acquiring = [];\r\n    for (const scope of scopeIter) {\r\n      let lock = locks.get(scope);\r\n      if (!lock) {\r\n        lock = createLock(options);\r\n        locks.set(scope, lock);\r\n      }\r\n      const o = {\r\n        lock,\r\n        scope,\r\n        relase: null\r\n      };\r\n      acquiring.push(lock[opType](release => {\r\n        o.release = release;\r\n      }));\r\n      scopes.push(o);\r\n    }\r\n    await Promise.all(acquiring);\r\n    let result;\r\n    try {\r\n      result = fn(fn.length && onDone);\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n    if (result && result.then) {\r\n      if (!fn.length) {\r\n        result.then(onDone, onDone);\r\n      }\r\n      return await result;\r\n    }\r\n    if (!fn.length) {\r\n      onDone();\r\n    }\r\n    return result;\r\n    \r\n    function onDone() {\r\n      for (const scope of scopes) {\r\n        scope.release(() => {\r\n          if (!scope.lock.length) {\r\n            locks.delete(scope.scope);\r\n          }\r\n        });\r\n      }\r\n      scopes.length = 0;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  createLock,\r\n  createLockPool\r\n};\r\n","const {createLock} = require(\"@eight04/read-write-lock\");\r\n\r\nfunction debounced(fn) {\r\n  let timer = 0;\r\n  let q;\r\n  return () => {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    timer = setTimeout(run);\r\n    if (!q) {\r\n      q = defer();\r\n    }\r\n    return q.promise;\r\n  };\r\n  \r\n  function run() {\r\n    Promise.resolve(fn())\r\n      .then(q.resolve, q.reject);\r\n    timer = 0;\r\n    q = null;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n}\r\n\r\nfunction buildDrive(_drive) {\r\n  const drive = Object.create(_drive);\r\n  drive.get = async path => JSON.parse(await _drive.get(path));\r\n  drive.put = async (path, data) => await _drive.put(path, JSON.stringify(data));\r\n  drive.post = async (path, data) => await _drive.post(path, JSON.stringify(data));\r\n  drive.isInit = false;\r\n  \r\n  if (!drive.acquireLock) {\r\n    drive.acquireLock = acquireLock;\r\n    drive.releaseLock = releaseLock;\r\n  }\r\n  \r\n  if (!drive.getMeta) {\r\n    drive.getMeta = getMeta;\r\n    drive.putMeta = putMeta;\r\n  }\r\n  \r\n  if (!drive.peekChanges) {\r\n    drive.peekChanges = peekChanges;\r\n  }\r\n  \r\n  return drive;\r\n  \r\n  async function acquireLock(expire) {\r\n    try {\r\n      await this.post(\"lock.json\", {expire: Date.now() + expire * 60 * 1000});\r\n    } catch (err) {\r\n      if (err.code === \"EEXIST\") {\r\n        const data = await this.get(\"lock.json\");\r\n        if (Date.now() > data.expire) {\r\n          await this.delete(\"lock.json\");\r\n        }\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    await this.delete(\"lock.json\");\r\n  }\r\n  \r\n  async function getMeta() {\r\n    try {\r\n      return await this.get(\"meta.json\");\r\n    } catch (err) {\r\n      if (err.code === \"ENOENT\" || err.code === 404) {\r\n        return {};\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function putMeta(data) {\r\n    await this.put(\"meta.json\", data);\r\n  }\r\n  \r\n  async function peekChanges(oldMeta) {\r\n    const newMeta = await this.getMeta();\r\n    return newMeta.lastChange !== oldMeta.lastChange;\r\n  }\r\n}\r\n\r\nfunction dbToCloud({\r\n  onGet,\r\n  onPut,\r\n  onDelete,\r\n  onFirstSync,\r\n  onWarn = console.error,\r\n  onProgress,\r\n  compareRevision,\r\n  getState,\r\n  setState,\r\n  lockExpire = 60\r\n}) {\r\n  let drive;\r\n  let state;\r\n  let meta;\r\n  const changeCache = new Map;\r\n  const saveState = debounced(() => setState(drive, state));\r\n  const revisionCache = new Map;\r\n  const lock = createLock();\r\n  return {\r\n    use,\r\n    init,\r\n    uninit,\r\n    put,\r\n    delete: delete_,\r\n    syncNow,\r\n    drive: () => drive,\r\n    isInit: () => Boolean(state && state.enabled)\r\n  };\r\n  \r\n  function use(newDrive) {\r\n    drive = buildDrive(newDrive);\r\n  }\r\n  \r\n  function init() {\r\n    return lock.write(async () => {\r\n      if (state && state.enabled) {\r\n        return;\r\n      }\r\n      if (!drive) {\r\n        throw new Error(\"cloud drive is undefined\");\r\n      }\r\n      \r\n      state = await getState(drive) || {};\r\n      state.enabled = true;\r\n      if (!state.queue) {\r\n        state.queue = [];\r\n      }\r\n    });\r\n  }\r\n  \r\n  function uninit() {\r\n    return lock.write(async () => {\r\n      if (!state || !state.enabled) {\r\n        return;\r\n      }\r\n      state = meta = null;\r\n      changeCache.clear();\r\n      revisionCache.clear();\r\n      if (drive.uninit && drive.isInit) {\r\n        await drive.uninit();\r\n        drive.isInit = false;\r\n      }\r\n      await saveState();\r\n    });\r\n  }\r\n  \r\n  async function syncPull() {\r\n    meta = await drive.getMeta();\r\n    if (!meta.lastChange || meta.lastChange === state.lastChange) {\r\n      // nothing changes\r\n      return;\r\n    }\r\n    let changes = [];\r\n    if (!state.lastChange) {\r\n      // pull everything\r\n      changes = (await drive.list(\"docs\"))\r\n        .map(name => ({action: 'put', _id: name.slice(0, -5)}));\r\n    } else {\r\n      const end = Math.floor((meta.lastChange - 1) / 100); // inclusive end\r\n      let i = Math.floor(state.lastChange / 100);\r\n      while (i <= end) {\r\n        const newChanges = await drive.get(`changes/${i}.json`);\r\n        changeCache.set(i, newChanges);\r\n        changes = changes.concat(newChanges);\r\n        i++;\r\n      }\r\n      changes = changes.slice(state.lastChange % 100);\r\n    }\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    let loaded = 0;\r\n    for (const [id, change] of idx) {\r\n      let doc, _rev;\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'pull',\r\n          total: idx.size,\r\n          loaded,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await onDelete(id, change._rev);\r\n      } else if (change.action === \"put\") {\r\n        try {\r\n          ({doc, _rev} = await drive.get(`docs/${id}.json`));\r\n        } catch (err) {\r\n          if (err.code === \"ENOENT\" || err.code === 404) {\r\n            onWarn(`Cannot find ${id}. Is it deleted without updating the history?`);\r\n            loaded++;\r\n            continue;\r\n          }\r\n          throw err;\r\n        }\r\n        await onPut(doc);\r\n      }\r\n      // record the remote revision\r\n      const rev = change._rev || _rev;\r\n      if (rev) {\r\n        revisionCache.set(id, rev);\r\n      }\r\n      loaded++;\r\n    }\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function syncPush() {\r\n    if (!state.queue.length) {\r\n      // nothing to push\r\n      return;\r\n    }\r\n    // snapshot\r\n    const changes = state.queue.slice();\r\n\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    // drop outdated change\r\n    const newChanges = [];\r\n    for (const change of idx.values()) {\r\n      // FIXME: is it safe to assume that the local doc is newer when\r\n      // remoteRev is undefined?\r\n      const remoteRev = revisionCache.get(change._id);\r\n      if (remoteRev !== undefined && compareRevision(change._rev, remoteRev) <= 0) {\r\n        continue;\r\n      }\r\n      newChanges.push(change);\r\n    }\r\n    // FIXME: there should be no need to push data when !newChanges.length\r\n    \r\n    // start pushing\r\n    let loaded = 0;\r\n    for (const change of newChanges) {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'push',\r\n          loaded,\r\n          total: newChanges.length,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await drive.delete(`docs/${change._id}.json`);\r\n      } else if (change.action === \"put\") {\r\n        const doc = await onGet(change._id, change._rev);\r\n        await drive.put(`docs/${change._id}.json`, {doc, _rev: change._rev});\r\n      }\r\n      revisionCache.set(change._id, change._rev);\r\n      loaded++;\r\n    }\r\n    \r\n    // push changes\r\n    let lastChanges;\r\n    let index;\r\n    // meta is already pulled in syncPull\r\n    if (meta.lastChange) {\r\n      index = Math.floor(meta.lastChange / 100);\r\n      const len = meta.lastChange % 100;\r\n      lastChanges = len ?\r\n        changeCache.get(index) || await drive.get(`changes/${index}.json`) :\r\n        [];\r\n      // it is possible that JSON data contains more records defined by\r\n      // meta.lastChange\r\n      lastChanges = lastChanges.slice(0, len).concat(newChanges);\r\n    } else {\r\n      // first sync\r\n      index = 0;\r\n      lastChanges = newChanges;\r\n    }\r\n    \r\n    for (let i = 0; i * 100 < lastChanges.length; i++) {\r\n      const window = lastChanges.slice(i * 100, (i + 1) * 100);\r\n      await drive.put(`changes/${index + i}.json`, window);\r\n      changeCache.set(index + i, window);\r\n    }\r\n    meta.lastChange = (meta.lastChange || 0) + newChanges.length;\r\n    await drive.putMeta(meta);\r\n    \r\n    state.queue = state.queue.slice(changes.length);\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function sync() {\r\n    await drive.acquireLock(lockExpire);\r\n    try {\r\n      await syncPull();\r\n      await syncPush();\r\n    } finally {\r\n      await drive.releaseLock();\r\n    }\r\n  }\r\n  \r\n  function syncNow(peek) {\r\n    return lock.write(async () => {\r\n      if (!state || !state.enabled) {\r\n        throw new Error(\"Cannot sync now, the sync is not enabled\");\r\n      }\r\n      if (drive.init && !drive.isInit) {\r\n        await drive.init();\r\n        drive.isInit = true;\r\n      }\r\n      if (state.lastChange == null) {\r\n        await onFirstSync();\r\n      }\r\n      await _syncNow(peek);\r\n    });\r\n  }\r\n  \r\n  async function _syncNow(peek = true) {\r\n    if (onProgress) {\r\n      onProgress({\r\n        phase: 'start'\r\n      });\r\n    }\r\n    try {\r\n      if (!state.queue.length && peek && meta) {\r\n        const changed = await drive.peekChanges(meta);\r\n        if (!changed) {\r\n          return;\r\n        }\r\n      }\r\n      await sync();\r\n    } finally {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'end'\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  function put(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"put\"\r\n    });\r\n    saveState();\r\n  }\r\n  \r\n  function delete_(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"delete\"\r\n    });\r\n    saveState();\r\n  }\r\n}\r\n\r\nmodule.exports = {dbToCloud};\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction percentToByte(p) {\n    return String.fromCharCode(parseInt(p.slice(1), 16));\n}\nfunction encode(str) {\n    return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));\n}\nexports.encode = encode;\nfunction byteToPercent(b) {\n    return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`;\n}\nfunction decode(str) {\n    return decodeURIComponent(Array.from(atob(str), byteToPercent).join(\"\"));\n}\nexports.decode = decode;\n//# sourceMappingURL=browser.js.map","const {createLock} = require(\"@eight04/read-write-lock\");\r\nconst base64 = require(\"universal-base64\");\r\n\r\nclass RequestError extends Error {\r\n  constructor(message, origin, code = origin && origin.status) {\r\n    super(message);\r\n    this.code = code;\r\n    this.origin = origin;\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, RequestError);\r\n    }\r\n  }\r\n}\r\n\r\nfunction delay(time) {\r\n  return new Promise(resolve => setTimeout(resolve, time));\r\n}\r\n\r\nfunction createRequest({fetch, cooldown = 0, getAccessToken, username, password}) {\r\n  const lock = createLock();\r\n  const basicAuth = username || password ?\r\n    `Basic ${base64.encode(`${username}:${password}`)}` :\r\n    null;\r\n  return args => {\r\n    return lock.write(async done => {\r\n      try {\r\n        return await doRequest(args);\r\n      } finally {\r\n        if (!cooldown || !args.method || args.method === \"GET\") {\r\n          done();\r\n        } else {\r\n          setTimeout(done, cooldown);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  \r\n  async function doRequest({\r\n    path,\r\n    contentType,\r\n    headers: _headers,\r\n    format,\r\n    raw = false,\r\n    ...args\r\n  }) {\r\n    const headers = {};\r\n    if (getAccessToken) {\r\n      headers[\"Authorization\"] = `Bearer ${await getAccessToken()}`;\r\n    }\r\n    if (basicAuth) {\r\n      headers[\"Authorization\"] = basicAuth;\r\n    }\r\n    if (contentType) {\r\n      headers[\"Content-Type\"] = contentType;\r\n    }\r\n    Object.assign(headers, _headers);\r\n    while (true) { // eslint-disable-line no-constant-condition\r\n      // console.log(\"req\", path, args, headers);\r\n      const res = await fetch(path, {\r\n        headers,\r\n        ...args\r\n      });\r\n      // console.log(\"res\", path, args, res.status, headers);\r\n      if (!res.ok) {\r\n        const retry = res.headers.get(\"Retry-After\");\r\n        if (retry) {\r\n          const time = Number(retry);\r\n          if (time) {\r\n            await delay(time * 1000);\r\n            continue;\r\n          }\r\n        }\r\n        const text = await res.text();\r\n        throw new RequestError(`failed to fetch [${res.status}]: ${text}`, res);\r\n      }\r\n      if (raw) {\r\n        return res;\r\n      }\r\n      if (format) {\r\n        return await res[format]();\r\n      }\r\n      const resContentType = res.headers.get(\"Content-Type\");\r\n      if (/application\\/json/.test(resContentType)) {\r\n        return await res.json();\r\n      }\r\n      return await res.text();\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {createRequest, RequestError};\r\n","export function dirname(path) {\r\n  const dir = path.replace(/[/\\\\][^/\\\\]+\\/?$/, \"\");\r\n  if (dir === path) return \".\";\r\n  return dir;\r\n}\r\n","/* global self */\r\nconst {dirname} = require(\"path\");\r\n\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction arrayify(o) {\r\n  return Array.isArray(o) ? o : [o];\r\n}\r\n\r\nfunction xmlToJSON(node) {\r\n  // FIXME: xmldom doesn't support children\r\n  const children = Array.prototype.filter.call(node.childNodes, i => i.nodeType === 1);\r\n  if (!children.length) {\r\n    return node.textContent;\r\n  }\r\n  \r\n  const o = {};\r\n  for (const c of children) {\r\n    const cResult = xmlToJSON(c);\r\n    if (!o[c.localName]) {\r\n      o[c.localName] = cResult;\r\n    } else if (!Array.isArray(o[c.localName])) {\r\n      const list = [o[c.localName]];\r\n      list.push(cResult);\r\n      o[c.localName] = list;\r\n    } else {\r\n      o[c.localName].push(cResult);\r\n    }\r\n  }\r\n  return o;\r\n}\r\n\r\nfunction createDrive({\r\n  username,\r\n  password,\r\n  url,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\r\n  DOMParser = (typeof self !== \"undefined\" ? self : global).DOMParser,\r\n}) {\r\n  if (!url.endsWith(\"/\")) {\r\n    url += \"/\";\r\n  }\r\n  let lockToken;\r\n  const request = createRequest({fetch, username, password});\r\n  return {\r\n    name: \"webdav\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    // acquireLock,\r\n    // releaseLock\r\n  };\r\n  \r\n  async function requestDAV({path, ...args}) {\r\n    if (lockToken) {\r\n      args.headers = args.headers || {};\r\n      args.headers[\"If\"] = `(${lockToken})`;\r\n    }\r\n    const text = await request({\r\n      path: `${url}${path}`,\r\n      ...args\r\n    });\r\n    if (args.format || typeof text !== \"string\" || !text) return text;\r\n    \r\n    const parser = new DOMParser;\r\n    const xml = parser.parseFromString(text, \"application/xml\");\r\n    const result = xmlToJSON(xml);\r\n    if (result.error) {\r\n      throw new Error(`Failed requesting DAV at ${url}${path}: ${JSON.stringify(result.error)}`);\r\n    }\r\n    if (result.multistatus) {\r\n      result.multistatus.response = arrayify(result.multistatus.response);\r\n      for (const r of result.multistatus.response) {\r\n        if (r.error) {\r\n          throw new Error(`Failed requesting DAV at ${url}${path}: ${r.href} ${r.error}`);\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  \r\n  async function list(file) {\r\n    if (!file.endsWith(\"/\")) {\r\n      file += \"/\";\r\n    }\r\n    const result = await requestDAV({\r\n      method: \"PROPFIND\",\r\n      path: file,\r\n      contentType: \"application/xml\",\r\n      body: \r\n        `<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n        <propfind xmlns=\"DAV:\">\r\n          <allprop/>\r\n        </propfind>`,\r\n      headers: {\r\n        \"Depth\": \"1\"\r\n      }\r\n    });\r\n    \r\n    const files = [];\r\n    for (const entry of arrayify(result.multistatus.response)) {\r\n      if (arrayify(entry.propstat).some(s => s.prop.resourcetype && s.prop.resourcetype.collection !== undefined)) {\r\n        continue;\r\n      }\r\n      const base = `${url}${file}`;\r\n      const absUrl = new URL(entry.href, base).href;\r\n      const name = absUrl.slice(base.length);\r\n      files.push(name);\r\n    }\r\n    return files;\r\n  }\r\n  \r\n  async function get(file) {\r\n    return await requestDAV({\r\n      method: \"GET\",\r\n      path: file,\r\n      format: \"text\"\r\n    });\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    return await withDir(\r\n      dirname(file),\r\n      () => requestDAV({\r\n        method: \"PUT\",\r\n        path: file,\r\n        contentType: \"application/octet-stream\",\r\n        body: data\r\n      })\r\n    );\r\n  }\r\n  \r\n  async function withDir(dir, cb) {\r\n    try {\r\n      return await cb();\r\n    } catch (err) {\r\n      if (err.code !== 409 && err.code !== 404 || dir === \".\") {\r\n        throw err;\r\n      }\r\n    }\r\n    await withDir(dirname(dir), () =>\r\n      requestDAV({\r\n        method: \"MKCOL\",\r\n        path: dir\r\n      })\r\n    );\r\n    return await cb();\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      return await withDir(\r\n        dirname(file),\r\n        () => requestDAV({\r\n          method: \"PUT\",\r\n          path: file,\r\n          body: data,\r\n          contentType: \"octet-stream\",\r\n          headers: {\r\n            // FIXME: seems webdav-server doesn't support etag, what about others?\r\n            \"If-None-Match\": \"*\"\r\n          }\r\n        })\r\n      );\r\n    } catch (err) {\r\n      if (err.code === 412) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    // FIXME: support deleting collections?\r\n    // FIXME: handle errors?\r\n    try {\r\n      await requestDAV({\r\n        method: \"DELETE\",\r\n        path: file\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) return;\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  // async function acquireLock(mins) {\r\n    // const r = await requestDAV({\r\n      // method: \"LOCK\",\r\n      // path: \"\",\r\n      // body: \r\n        // `<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n        // <lockinfo xmlns='DAV:'> \r\n          // <lockscope><exclusive/></lockscope> \r\n          // <locktype><write/></locktype> \r\n        // </lockinfo> `,\r\n      // headers: {\r\n        // \"Timeout\": `Second-${mins * 60}`\r\n      // },\r\n      // raw: true\r\n    // });\r\n    // lockToken = r.headers.get(\"Lock-Token\");\r\n  // }\r\n  \r\n  // async function releaseLock() {\r\n    // await requestDAV({\r\n      // method: \"UNLOCK\",\r\n      // path: \"\",\r\n      // headers: {\r\n        // \"Lock-Token\": lockToken\r\n      // }\r\n    // });\r\n  // }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst base64 = require(\"universal-base64\");\r\n\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  userAgent = \"db-to-cloud\",\r\n  owner,\r\n  repo,\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken, cooldown: 1000});\r\n  const shaCache = new Map;\r\n  return {\r\n    name: \"github\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    shaCache\r\n  };\r\n  \r\n  function requestAPI(args) {\r\n    if (!args.headers) {\r\n      args.headers = {};\r\n    }\r\n    if (!args.headers[\"User-Agent\"]) {\r\n      args.headers[\"User-Agent\"] = userAgent;\r\n    }\r\n    if (!args.headers[\"Accept\"]) {\r\n      args.headers[\"Accept\"] = \"application/vnd.github.v3+json\";\r\n    }\r\n    args.path = `https://api.github.com${args.path}`;\r\n    return request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the Git Trees API.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    const names = [];\r\n    for (const item of result) {\r\n      names.push(item.name);\r\n      shaCache.set(item.path, item.sha);\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  async function get(file) {\r\n    // FIXME: This API supports files up to 1 megabyte in size.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    shaCache.set(result.path, result.sha);\r\n    return base64.decode(result.content);\r\n  }\r\n  \r\n  async function put(file, data, overwrite = true) {\r\n    const params = {\r\n      message: \"\",\r\n      content: base64.encode(data)\r\n    };\r\n    if (overwrite && shaCache.has(file)) {\r\n      params.sha = shaCache.get(file);\r\n    }\r\n    const args = {\r\n      method: \"PUT\",\r\n      path: `/repos/${owner}/${repo}/contents/${file}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(params)\r\n    };\r\n    let retried = false;\r\n    let result;\r\n    while (!result) {\r\n      try {\r\n        result = await requestAPI(args);\r\n      } catch (err) {\r\n        if (err.code !== 422 || !err.message.includes(\"\\\\\\\"sha\\\\\\\" wasn't supplied\")) {\r\n          throw err;\r\n        }\r\n        if (!overwrite || retried) {\r\n          err.code = \"EEXIST\";\r\n          throw err;\r\n        }\r\n        await get(file);\r\n      }\r\n      retried = true;\r\n    }\r\n    shaCache.set(file, result.content.sha);\r\n  }\r\n  \r\n  function post(file, data) {\r\n    return put(file, data, false);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      let sha = shaCache.get(file);\r\n      if (!sha) {\r\n        await get(file);\r\n        sha = shaCache.get(file);\r\n      }\r\n      await requestAPI({\r\n        method: \"DELETE\",\r\n        path: `/repos/${owner}/${repo}/contents/${file}`,\r\n        body: JSON.stringify({\r\n          message: \"\",\r\n          sha\r\n        })\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      // FIXME: do we have to handle 422 errors?\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"dropbox\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  function requestRPC({path, body, ...args}) {\r\n    return request({\r\n      method: \"POST\",\r\n      path: `https://api.dropboxapi.com/2/${path}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(body),\r\n      ...args\r\n    });\r\n  }\r\n  \r\n  async function list(file) {\r\n    const names = [];\r\n    let result = await requestRPC({\r\n      path: \"files/list_folder\",\r\n      body: {\r\n        path: `/${file}`\r\n      }\r\n    });\r\n    for (const entry of result.entries) {\r\n      names.push(entry.name);\r\n    }\r\n    if (!result.has_more) {\r\n      return names;\r\n    }\r\n    while (result.has_more) {\r\n      result = await requestRPC({\r\n        path: \"files/list_folder/continue\",\r\n        body: {\r\n          cursor: result.cursor\r\n        }\r\n      });\r\n      for (const entry of result.entries) {\r\n        names.push(entry.name);\r\n      }\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  function stringifyParams(obj) {\r\n    const params = new URLSearchParams;\r\n    params.set(\"arg\", JSON.stringify(obj));\r\n    return params.toString();\r\n  }\r\n  \r\n  async function get(file) {\r\n    const params = {\r\n      path: `/${file}`\r\n    };\r\n    try {\r\n      return await request({\r\n        path: `https://content.dropboxapi.com/2/files/download?${stringifyParams(params)}`,\r\n        format: \"text\"\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data, mode = \"overwrite\") {\r\n    const params = {\r\n      path: `/${file}`,\r\n      mode,\r\n      autorename: false,\r\n      mute: true\r\n    };\r\n    await request({\r\n      path: `https://content.dropboxapi.com/2/files/upload?${stringifyParams(params)}`,\r\n      method: \"POST\",\r\n      contentType: \"application/octet-stream\",\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      return await put(file, data, \"add\");\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"conflict\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await requestRPC({\r\n        path: \"files/delete_v2\",\r\n        body: {\r\n          path: `/${file}`\r\n        }\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"onedrive\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  async function query(args) {\r\n    args.path = `https://graph.microsoft.com/v1.0/me/drive/special/approot${args.path}`;\r\n    return await request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    if (file) {\r\n      file = `:/${file}:`;\r\n    }\r\n    let result = await query({\r\n      path: `${file}/children?select=name`\r\n    });\r\n    let files = result.value.map(i => i.name);\r\n    while (result[\"@odata.nextLink\"]) {\r\n      result = await request({\r\n        path: result[\"@odata.nextLink\"]\r\n      });\r\n      files = files.concat(result.value.map(i => i.name));\r\n    }\r\n    return files;\r\n  }\r\n  \r\n  async function get(file) {\r\n    return await query({\r\n      path: `:/${file}:/content`,\r\n      format: \"text\"\r\n    });\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    await query({\r\n      method: \"PUT\",\r\n      path: `:/${file}:/content`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      await query({\r\n        method: \"PUT\",\r\n        path: `:/${file}:/content?@microsoft.graph.conflictBehavior=fail`,\r\n        headers: {\r\n          \"Content-Type\": \"text/plain\"\r\n        },\r\n        body: data\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"nameAlreadyExists\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await query({\r\n        method: \"DELETE\",\r\n        path: `:/${file}:`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest, RequestError} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\r\n  FormData = (typeof self !== \"undefined\" ? self : global).FormData,\r\n  Blob = (typeof self !== \"undefined\" ? self : global).Blob\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  const fileMetaCache = new Map;\r\n  let lockRev;\r\n  return {\r\n    name: \"google\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    init,\r\n    acquireLock,\r\n    releaseLock,\r\n    fileMetaCache\r\n  };\r\n  \r\n  async function revDelete(fileId, revId) {\r\n    await request({\r\n      method: \"DELETE\",\r\n      path: `https://www.googleapis.com/drive/v3/files/${fileId}/revisions/${revId}`\r\n    });\r\n  }\r\n  \r\n  async function acquireLock(expire) {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    const {headRevisionId} = await queryPatch(lock.id, JSON.stringify({expire: Date.now() + expire * 60 * 1000}));\r\n    const result = await request({\r\n      path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions?fields=revisions(id)`\r\n    });\r\n    for (let i = 1; i < result.revisions.length; i++) {\r\n      const revId = result.revisions[i].id;\r\n      if (revId === headRevisionId) {\r\n        // success\r\n        lockRev = headRevisionId;\r\n        return;\r\n      }\r\n      const rev = JSON.parse(await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions/${revId}?alt=media`\r\n      }));\r\n      if (rev.expire > Date.now()) {\r\n        // failed, delete the lock\r\n        await revDelete(lock.id, headRevisionId);\r\n        throw new RequestError(\"failed to acquire lock\", null, \"EEXIST\");\r\n      }\r\n      // delete outdated lock\r\n      await revDelete(lock.id, revId);\r\n    }\r\n    throw new Error(\"cannot find lock revision\");\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    await revDelete(lock.id, lockRev);\r\n    lockRev = null;\r\n  }\r\n  \r\n  async function queryList(path, onPage) {\r\n    path = \"https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&fields=nextPageToken,files(id,name,headRevisionId)\" + (path ? \"&\" + path : \"\");\r\n    let result = await request({path});\r\n    onPage(result);\r\n    while (result.nextPageToken) {\r\n      result = await request({path: `${path}&pageToken=${result.nextPageToken}`});\r\n      onPage(result);\r\n    }\r\n  }\r\n  \r\n  async function queryPatch(id, text) {\r\n    return await request({\r\n      method: \"PATCH\",\r\n      path: `https://www.googleapis.com/upload/drive/v3/files/${id}?uploadType=media&fields=headRevisionId`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: text\r\n    });\r\n  }\r\n  \r\n  async function updateMeta(query) {\r\n    if (query) {\r\n      query = `q=${encodeURIComponent(query)}`;\r\n    }\r\n    await queryList(query, result => {\r\n      for (const file of result.files) {\r\n        fileMetaCache.set(file.name, file);\r\n      }\r\n    });\r\n  }\r\n  \r\n  async function init() {\r\n    await updateMeta();\r\n    if (!fileMetaCache.has(\"lock.json\")) {\r\n      await post(\"lock.json\", \"{}\");\r\n    }\r\n    if (!fileMetaCache.has(\"meta.json\")) {\r\n      await post(\"meta.json\", \"{}\");\r\n    }\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: this only works if file is a single dir\r\n    // FIXME: this only works if the list method is called right after init, use\r\n    // queryList instead?\r\n    return [...fileMetaCache.values()]\r\n      .filter(f => f.name.startsWith(file + \"/\"))\r\n      .map(f => f.name.split(\"/\")[1]);\r\n  }\r\n  \r\n  async function get(file) {\r\n    let meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      await updateMeta(`name = '${file}'`);\r\n      meta = fileMetaCache.get(file);\r\n      if (!meta) {\r\n        throw new RequestError(`metaCache doesn't contain ${file}`, null, \"ENOENT\");\r\n      }\r\n    }\r\n    try {\r\n      return await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}?alt=media`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    if (!fileMetaCache.has(file)) {\r\n      return await post(file, data);\r\n    }\r\n    const meta = fileMetaCache.get(file);\r\n    const result = await queryPatch(meta.id, data);\r\n    meta.headRevisionId = result.headRevisionId;\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    const body = new FormData;\r\n    const meta = {\r\n      name: file,\r\n      parents: [\"appDataFolder\"]\r\n    };\r\n    body.append(\"metadata\", new Blob([JSON.stringify(meta)], {type: \"application/json; charset=UTF-8\"}));\r\n    body.append(\"media\", new Blob([data], {type: \"text/plain\"}));\r\n    const result = await request({\r\n      method: \"POST\",\r\n      path: \"https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,headRevisionId\",\r\n      body\r\n    });\r\n    fileMetaCache.set(result.name, result);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    const meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      return;\r\n    }\r\n    try {\r\n      await request({\r\n        method: \"DELETE\",\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n"],"names":["createLock","maxActiveReader","Infinity","firstTask","lastTask","activeReader","self","read","fn","que","write","length","block","task","prev","next","q","defer","q2","createTask","deque","promise","o","Promise","resolve","reject","result","err","onDone","then","_onDone","pending","afterDone","debounced","timer","clearTimeout","setTimeout","run","percentToByte","btoa","encodeURIComponent","byteToPercent","b","charCodeAt","decode","decodeURIComponent","Array","from","atob","str","join","RequestError","Error","constructor","message","origin","code","status","captureStackTrace","this","delay","time","createRequest","fetch","cooldown","getAccessToken","username","password","lock","basicAuth","base64","args","done","doRequest","method","path","contentType","_headers","headers","format","raw","Object","assign","res","ok","retry","get","Number","text","resContentType","test","json","dirname","dir","replace","arrayify","isArray","xmlToJSON","node","children","prototype","filter","call","childNodes","i","nodeType","textContent","c","cResult","localName","push","list","userAgent","owner","repo","global","request","shaCache","Map","name","put","post","file","data","delete","requestAPI","names","item","set","sha","content","overwrite","params","has","body","JSON","stringify","retried","includes","requestRPC","entries","entry","has_more","cursor","stringifyParams","obj","URLSearchParams","toString","mode","autorename","mute","query","files","value","map","concat","FormData","Blob","fileMetaCache","lockRev","init","acquireLock","releaseLock","revDelete","fileId","revId","expire","headRevisionId","queryPatch","id","Date","now","revisions","parse","queryList","onPage","nextPageToken","updateMeta","values","f","startsWith","split","meta","parents","append","type","url","DOMParser","endsWith","requestDAV","parseFromString","error","multistatus","response","r","href","propstat","some","s","prop","resourcetype","undefined","collection","base","URL","slice","withDir","cb","onGet","onPut","onDelete","onFirstSync","onWarn","console","onProgress","compareRevision","getState","setState","lockExpire","drive","state","changeCache","saveState","revisionCache","use","newDrive","_drive","create","isInit","getMeta","putMeta","peekChanges","oldMeta","lastChange","buildDrive","enabled","queue","uninit","clear","_id","_rev","action","syncNow","peek","_syncNow","Boolean","syncPull","changes","end","Math","floor","newChanges","idx","change","loaded","doc","phase","total","size","rev","syncPush","remoteRev","lastChanges","index","len","window","sync"],"mappings":"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"}