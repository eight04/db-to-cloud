{"version":3,"file":"db-to-cloud.min.js","sources":["../node_modules/@eight04/read-write-lock/index.js","../lib/lock.js","../lib/util.js","../node_modules/universal-base64/dist/browser.js","../lib/request.js","../shim/path.mjs","../lib/drive/webdav.js","../lib/drive/github.js","../lib/drive/dropbox.js","../lib/drive/onedrive.js","../lib/drive/google.js","../lib/db-to-cloud.js"],"sourcesContent":["function createLock({maxActiveReader = Infinity} = {}) {\r\n  let firstTask;\r\n  let lastTask;\r\n  let activeReader = 0;\r\n  const self = {\r\n    read: fn => que(fn, false),\r\n    write: fn => que(fn, true),\r\n    length: 0\r\n  };\r\n  return self;\r\n  \r\n  function que(fn, block) {\r\n    const task = createTask({fn, block});\r\n    if (!lastTask) {\r\n      firstTask = lastTask = task;\r\n    } else {\r\n      lastTask.next = task;\r\n      task.prev = lastTask;\r\n      lastTask = task;\r\n      if (!firstTask) {\r\n        firstTask = lastTask;\r\n      }\r\n    }\r\n    self.length++;\r\n    deque();\r\n    return task.q.promise;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n  \r\n  function createTask({\r\n    fn,\r\n    block = false,\r\n    prev,\r\n    next,\r\n    q = defer(),\r\n    q2 = fn.length ? defer() : null\r\n  }) {\r\n    return {fn, block, prev, next, q, q2};\r\n  }\r\n  \r\n  function deque() {\r\n    const task = firstTask;\r\n    if (\r\n      !task ||\r\n      task.block && task.prev ||\r\n      task.prev && task.prev.block ||\r\n      activeReader >= maxActiveReader\r\n    ) {\r\n      return;\r\n    }\r\n    if (!task.block) {\r\n      activeReader++;\r\n    }\r\n    firstTask = task.next;\r\n    let result;\r\n    try {\r\n      result = task.fn(task.q2 && task.q2.resolve);\r\n    } catch (err) {\r\n      task.q.reject(err);\r\n      // auto release with sync error\r\n      // q2 is useless in this case\r\n      onDone();\r\n      return;\r\n    }\r\n    if (task.q2) {\r\n      task.q2.promise.then(_onDone);\r\n    }\r\n    if (result && result.then) {\r\n      const pending = result.then(task.q.resolve, task.q.reject);\r\n      if (!task.q2) {\r\n        pending.then(onDone);\r\n      }\r\n    } else {\r\n      task.q.resolve(result);\r\n      if (!task.q2) {\r\n        // it's a sync function and you don't want to release it manually, why\r\n        // do you need a lock?\r\n        onDone();\r\n        return;\r\n      }\r\n    }\r\n    deque();\r\n    \r\n    function onDone() {\r\n      _onDone();\r\n    }\r\n    \r\n    function _onDone(afterDone) {\r\n      if (task.prev) {\r\n        task.prev.next = task.next;\r\n      }\r\n      if (task.next) {\r\n        task.next.prev = task.prev;\r\n      }\r\n      if (lastTask === task) {\r\n        lastTask = task.prev;\r\n      }\r\n      if (!task.block) {\r\n        activeReader--;\r\n      }\r\n      self.length--;\r\n      if (afterDone) {\r\n        afterDone();\r\n      }\r\n      deque();\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLockPool(options) {\r\n  const locks = new Map; // scope -> lock\r\n  return {\r\n    read: (scope, fn) => op(scope, fn, \"read\"),\r\n    write: (scope, fn) => op(scope, fn, \"write\"),\r\n    locks\r\n  };\r\n  \r\n  async function op(scopeIter, fn, opType) {\r\n    // FIXME: dead lock if there are duplicated scopes?\r\n    const scopes = [];\r\n    const acquiring = [];\r\n    for (const scope of scopeIter) {\r\n      let lock = locks.get(scope);\r\n      if (!lock) {\r\n        lock = createLock(options);\r\n        locks.set(scope, lock);\r\n      }\r\n      const o = {\r\n        lock,\r\n        scope,\r\n        relase: null\r\n      };\r\n      acquiring.push(lock[opType](release => {\r\n        o.release = release;\r\n      }));\r\n      scopes.push(o);\r\n    }\r\n    await Promise.all(acquiring);\r\n    let result;\r\n    try {\r\n      result = fn(fn.length && onDone);\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n    if (result && result.then) {\r\n      if (!fn.length) {\r\n        result.then(onDone, onDone);\r\n      }\r\n      return await result;\r\n    }\r\n    if (!fn.length) {\r\n      onDone();\r\n    }\r\n    return result;\r\n    \r\n    function onDone() {\r\n      for (const scope of scopes) {\r\n        scope.release(() => {\r\n          if (!scope.lock.length) {\r\n            locks.delete(scope.scope);\r\n          }\r\n        });\r\n      }\r\n      scopes.length = 0;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  createLock,\r\n  createLockPool\r\n};\r\n","class LockError extends Error {\r\n  constructor(expire) {\r\n    super(`The database is locked. Will expire at ${new Date(expire).toLocaleString()}`);\r\n    this.expire = expire;\r\n    this.name = \"LockError\";\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, LockError);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {LockError};\r\n","function debounced(fn) {\r\n  let timer = 0;\r\n  let q;\r\n  return () => {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    timer = setTimeout(run);\r\n    if (!q) {\r\n      q = defer();\r\n    }\r\n    return q.promise;\r\n  };\r\n  \r\n  function run() {\r\n    Promise.resolve(fn())\r\n      .then(q.resolve, q.reject);\r\n    timer = 0;\r\n    q = null;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n}\r\n\r\nfunction delay(time) {\r\n  return new Promise(resolve => setTimeout(resolve, time));\r\n}\r\n\r\nmodule.exports = {debounced, delay};\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction percentToByte(p) {\n    return String.fromCharCode(parseInt(p.slice(1), 16));\n}\nfunction encode(str) {\n    return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));\n}\nexports.encode = encode;\nfunction byteToPercent(b) {\n    return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`;\n}\nfunction decode(str) {\n    return decodeURIComponent(Array.from(atob(str), byteToPercent).join(\"\"));\n}\nexports.decode = decode;\n//# sourceMappingURL=browser.js.map","const {createLock} = require(\"@eight04/read-write-lock\");\r\nconst base64 = require(\"universal-base64\");\r\n\r\nconst {delay} = require(\"./util\");\r\n\r\nclass RequestError extends Error {\r\n  constructor(message, origin, code = origin && origin.status) {\r\n    super(message);\r\n    this.code = code;\r\n    this.origin = origin;\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, RequestError);\r\n    }\r\n  }\r\n}\r\n\r\nfunction createRequest({fetch, cooldown = 0, getAccessToken, username, password}) {\r\n  const lock = createLock();\r\n  const basicAuth = username || password ?\r\n    `Basic ${base64.encode(`${username}:${password}`)}` :\r\n    null;\r\n  return args => {\r\n    return lock.write(async done => {\r\n      try {\r\n        return await doRequest(args);\r\n      } finally {\r\n        if (!cooldown || !args.method || args.method === \"GET\") {\r\n          done();\r\n        } else {\r\n          setTimeout(done, cooldown);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  \r\n  async function doRequest({\r\n    path,\r\n    contentType,\r\n    headers: _headers,\r\n    format,\r\n    raw = false,\r\n    ...args\r\n  }) {\r\n    const headers = {};\r\n    if (getAccessToken) {\r\n      headers[\"Authorization\"] = `Bearer ${await getAccessToken()}`;\r\n    }\r\n    if (basicAuth) {\r\n      headers[\"Authorization\"] = basicAuth;\r\n    }\r\n    if (contentType) {\r\n      headers[\"Content-Type\"] = contentType;\r\n    }\r\n    Object.assign(headers, _headers);\r\n    while (true) { // eslint-disable-line no-constant-condition\r\n      // console.log(\"req\", path, args, headers);\r\n      const res = await fetch(path, {\r\n        headers,\r\n        ...args\r\n      });\r\n      // console.log(\"res\", path, args, res.status, headers);\r\n      if (!res.ok) {\r\n        const retry = res.headers.get(\"Retry-After\");\r\n        if (retry) {\r\n          const time = Number(retry);\r\n          if (time) {\r\n            await delay(time * 1000);\r\n            continue;\r\n          }\r\n        }\r\n        const text = await res.text();\r\n        throw new RequestError(`failed to fetch [${res.status}]: ${text}`, res);\r\n      }\r\n      if (raw) {\r\n        return res;\r\n      }\r\n      if (format) {\r\n        return await res[format]();\r\n      }\r\n      const resContentType = res.headers.get(\"Content-Type\");\r\n      if (/application\\/json/.test(resContentType)) {\r\n        return await res.json();\r\n      }\r\n      return await res.text();\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {createRequest, RequestError};\r\n","export function dirname(path) {\r\n  const dir = path.replace(/[/\\\\][^/\\\\]+\\/?$/, \"\");\r\n  if (dir === path) return \".\";\r\n  return dir;\r\n}\r\n","/* global self */\r\nconst {dirname} = require(\"path\");\r\n\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction arrayify(o) {\r\n  return Array.isArray(o) ? o : [o];\r\n}\r\n\r\nfunction xmlToJSON(node) {\r\n  // FIXME: xmldom doesn't support children\r\n  const children = Array.prototype.filter.call(node.childNodes, i => i.nodeType === 1);\r\n  if (!children.length) {\r\n    return node.textContent;\r\n  }\r\n  \r\n  const o = {};\r\n  for (const c of children) {\r\n    const cResult = xmlToJSON(c);\r\n    if (!o[c.localName]) {\r\n      o[c.localName] = cResult;\r\n    } else if (!Array.isArray(o[c.localName])) {\r\n      const list = [o[c.localName]];\r\n      list.push(cResult);\r\n      o[c.localName] = list;\r\n    } else {\r\n      o[c.localName].push(cResult);\r\n    }\r\n  }\r\n  return o;\r\n}\r\n\r\nfunction createDrive({\r\n  username,\r\n  password,\r\n  url,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\r\n  DOMParser = (typeof self !== \"undefined\" ? self : global).DOMParser,\r\n}) {\r\n  if (!url.endsWith(\"/\")) {\r\n    url += \"/\";\r\n  }\r\n  let lockToken;\r\n  const request = createRequest({fetch, username, password});\r\n  return {\r\n    name: \"webdav\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    // acquireLock,\r\n    // releaseLock\r\n  };\r\n  \r\n  async function requestDAV({path, ...args}) {\r\n    if (lockToken) {\r\n      args.headers = args.headers || {};\r\n      args.headers[\"If\"] = `(${lockToken})`;\r\n    }\r\n    const text = await request({\r\n      path: `${url}${path}`,\r\n      ...args\r\n    });\r\n    if (args.format || typeof text !== \"string\" || !text) return text;\r\n    \r\n    const parser = new DOMParser;\r\n    const xml = parser.parseFromString(text, \"application/xml\");\r\n    const result = xmlToJSON(xml);\r\n    if (result.error) {\r\n      throw new Error(`Failed requesting DAV at ${url}${path}: ${JSON.stringify(result.error)}`);\r\n    }\r\n    if (result.multistatus) {\r\n      result.multistatus.response = arrayify(result.multistatus.response);\r\n      for (const r of result.multistatus.response) {\r\n        if (r.error) {\r\n          throw new Error(`Failed requesting DAV at ${url}${path}: ${r.href} ${r.error}`);\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  \r\n  async function list(file) {\r\n    if (!file.endsWith(\"/\")) {\r\n      file += \"/\";\r\n    }\r\n    const result = await requestDAV({\r\n      method: \"PROPFIND\",\r\n      path: file,\r\n      contentType: \"application/xml\",\r\n      body: \r\n        `<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n        <propfind xmlns=\"DAV:\">\r\n          <allprop/>\r\n        </propfind>`,\r\n      headers: {\r\n        \"Depth\": \"1\"\r\n      }\r\n    });\r\n    \r\n    const files = [];\r\n    for (const entry of arrayify(result.multistatus.response)) {\r\n      if (arrayify(entry.propstat).some(s => s.prop.resourcetype && s.prop.resourcetype.collection !== undefined)) {\r\n        continue;\r\n      }\r\n      const base = `${url}${file}`;\r\n      const absUrl = new URL(entry.href, base).href;\r\n      const name = absUrl.slice(base.length);\r\n      files.push(name);\r\n    }\r\n    return files;\r\n  }\r\n  \r\n  async function get(file) {\r\n    return await requestDAV({\r\n      method: \"GET\",\r\n      path: file,\r\n      format: \"text\"\r\n    });\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    return await withDir(\r\n      dirname(file),\r\n      () => requestDAV({\r\n        method: \"PUT\",\r\n        path: file,\r\n        contentType: \"application/octet-stream\",\r\n        body: data\r\n      })\r\n    );\r\n  }\r\n  \r\n  async function withDir(dir, cb) {\r\n    try {\r\n      return await cb();\r\n    } catch (err) {\r\n      if (err.code !== 409 && err.code !== 404 || dir === \".\") {\r\n        throw err;\r\n      }\r\n    }\r\n    await withDir(dirname(dir), () =>\r\n      requestDAV({\r\n        method: \"MKCOL\",\r\n        path: dir\r\n      })\r\n    );\r\n    return await cb();\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      return await withDir(\r\n        dirname(file),\r\n        () => requestDAV({\r\n          method: \"PUT\",\r\n          path: file,\r\n          body: data,\r\n          contentType: \"octet-stream\",\r\n          headers: {\r\n            // FIXME: seems webdav-server doesn't support etag, what about others?\r\n            \"If-None-Match\": \"*\"\r\n          }\r\n        })\r\n      );\r\n    } catch (err) {\r\n      if (err.code === 412) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    // FIXME: support deleting collections?\r\n    // FIXME: handle errors?\r\n    try {\r\n      await requestDAV({\r\n        method: \"DELETE\",\r\n        path: file\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) return;\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  // async function acquireLock(mins) {\r\n    // const r = await requestDAV({\r\n      // method: \"LOCK\",\r\n      // path: \"\",\r\n      // body: \r\n        // `<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n        // <lockinfo xmlns='DAV:'> \r\n          // <lockscope><exclusive/></lockscope> \r\n          // <locktype><write/></locktype> \r\n        // </lockinfo> `,\r\n      // headers: {\r\n        // \"Timeout\": `Second-${mins * 60}`\r\n      // },\r\n      // raw: true\r\n    // });\r\n    // lockToken = r.headers.get(\"Lock-Token\");\r\n  // }\r\n  \r\n  // async function releaseLock() {\r\n    // await requestDAV({\r\n      // method: \"UNLOCK\",\r\n      // path: \"\",\r\n      // headers: {\r\n        // \"Lock-Token\": lockToken\r\n      // }\r\n    // });\r\n  // }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst base64 = require(\"universal-base64\");\r\n\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  userAgent = \"db-to-cloud\",\r\n  owner,\r\n  repo,\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken, cooldown: 1000});\r\n  const shaCache = new Map;\r\n  return {\r\n    name: \"github\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    shaCache\r\n  };\r\n  \r\n  function requestAPI(args) {\r\n    if (!args.headers) {\r\n      args.headers = {};\r\n    }\r\n    if (!args.headers[\"User-Agent\"]) {\r\n      args.headers[\"User-Agent\"] = userAgent;\r\n    }\r\n    if (!args.headers[\"Accept\"]) {\r\n      args.headers[\"Accept\"] = \"application/vnd.github.v3+json\";\r\n    }\r\n    args.path = `https://api.github.com${args.path}`;\r\n    return request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the Git Trees API.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    const names = [];\r\n    for (const item of result) {\r\n      names.push(item.name);\r\n      shaCache.set(item.path, item.sha);\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  async function get(file) {\r\n    // FIXME: This API supports files up to 1 megabyte in size.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    shaCache.set(result.path, result.sha);\r\n    return base64.decode(result.content);\r\n  }\r\n  \r\n  async function put(file, data, overwrite = true) {\r\n    const params = {\r\n      message: \"\",\r\n      content: base64.encode(data)\r\n    };\r\n    if (overwrite && shaCache.has(file)) {\r\n      params.sha = shaCache.get(file);\r\n    }\r\n    const args = {\r\n      method: \"PUT\",\r\n      path: `/repos/${owner}/${repo}/contents/${file}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(params)\r\n    };\r\n    let retried = false;\r\n    let result;\r\n    while (!result) {\r\n      try {\r\n        result = await requestAPI(args);\r\n      } catch (err) {\r\n        if (err.code !== 422 || !err.message.includes(\"\\\\\\\"sha\\\\\\\" wasn't supplied\")) {\r\n          throw err;\r\n        }\r\n        if (!overwrite || retried) {\r\n          err.code = \"EEXIST\";\r\n          throw err;\r\n        }\r\n        await get(file);\r\n      }\r\n      retried = true;\r\n    }\r\n    shaCache.set(file, result.content.sha);\r\n  }\r\n  \r\n  function post(file, data) {\r\n    return put(file, data, false);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      let sha = shaCache.get(file);\r\n      if (!sha) {\r\n        await get(file);\r\n        sha = shaCache.get(file);\r\n      }\r\n      await requestAPI({\r\n        method: \"DELETE\",\r\n        path: `/repos/${owner}/${repo}/contents/${file}`,\r\n        body: JSON.stringify({\r\n          message: \"\",\r\n          sha\r\n        })\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      // FIXME: do we have to handle 422 errors?\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"dropbox\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  function requestRPC({path, body, ...args}) {\r\n    return request({\r\n      method: \"POST\",\r\n      path: `https://api.dropboxapi.com/2/${path}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(body),\r\n      ...args\r\n    });\r\n  }\r\n  \r\n  async function list(file) {\r\n    const names = [];\r\n    let result = await requestRPC({\r\n      path: \"files/list_folder\",\r\n      body: {\r\n        path: `/${file}`\r\n      }\r\n    });\r\n    for (const entry of result.entries) {\r\n      names.push(entry.name);\r\n    }\r\n    if (!result.has_more) {\r\n      return names;\r\n    }\r\n    while (result.has_more) {\r\n      result = await requestRPC({\r\n        path: \"files/list_folder/continue\",\r\n        body: {\r\n          cursor: result.cursor\r\n        }\r\n      });\r\n      for (const entry of result.entries) {\r\n        names.push(entry.name);\r\n      }\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  function stringifyParams(obj) {\r\n    const params = new URLSearchParams;\r\n    params.set(\"arg\", JSON.stringify(obj));\r\n    return params.toString();\r\n  }\r\n  \r\n  async function get(file) {\r\n    const params = {\r\n      path: `/${file}`\r\n    };\r\n    try {\r\n      return await request({\r\n        path: `https://content.dropboxapi.com/2/files/download?${stringifyParams(params)}`,\r\n        format: \"text\"\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data, mode = \"overwrite\") {\r\n    const params = {\r\n      path: `/${file}`,\r\n      mode,\r\n      autorename: false,\r\n      mute: true\r\n    };\r\n    await request({\r\n      path: `https://content.dropboxapi.com/2/files/upload?${stringifyParams(params)}`,\r\n      method: \"POST\",\r\n      contentType: \"application/octet-stream\",\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      return await put(file, data, \"add\");\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"conflict\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await requestRPC({\r\n        path: \"files/delete_v2\",\r\n        body: {\r\n          path: `/${file}`\r\n        }\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"onedrive\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  async function query(args) {\r\n    args.path = `https://graph.microsoft.com/v1.0/me/drive/special/approot${args.path}`;\r\n    return await request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    if (file) {\r\n      file = `:/${file}:`;\r\n    }\r\n    let result = await query({\r\n      path: `${file}/children?select=name`\r\n    });\r\n    let files = result.value.map(i => i.name);\r\n    while (result[\"@odata.nextLink\"]) {\r\n      result = await request({\r\n        path: result[\"@odata.nextLink\"]\r\n      });\r\n      files = files.concat(result.value.map(i => i.name));\r\n    }\r\n    return files;\r\n  }\r\n  \r\n  async function get(file) {\r\n    return await query({\r\n      path: `:/${file}:/content`,\r\n      format: \"text\"\r\n    });\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    await query({\r\n      method: \"PUT\",\r\n      path: `:/${file}:/content`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      await query({\r\n        method: \"PUT\",\r\n        path: `:/${file}:/content?@microsoft.graph.conflictBehavior=fail`,\r\n        headers: {\r\n          \"Content-Type\": \"text/plain\"\r\n        },\r\n        body: data\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"nameAlreadyExists\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await query({\r\n        method: \"DELETE\",\r\n        path: `:/${file}:`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest, RequestError} = require(\"../request\");\r\nconst {LockError} = require(\"../lock\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\r\n  FormData = (typeof self !== \"undefined\" ? self : global).FormData,\r\n  Blob = (typeof self !== \"undefined\" ? self : global).Blob\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  const fileMetaCache = new Map;\r\n  let lockRev;\r\n  return {\r\n    name: \"google\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    init,\r\n    acquireLock,\r\n    releaseLock,\r\n    fileMetaCache\r\n  };\r\n  \r\n  async function revDelete(fileId, revId) {\r\n    await request({\r\n      method: \"DELETE\",\r\n      path: `https://www.googleapis.com/drive/v3/files/${fileId}/revisions/${revId}`\r\n    });\r\n  }\r\n  \r\n  async function acquireLock(expire) {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    const {headRevisionId} = await queryPatch(lock.id, JSON.stringify({expire: Date.now() + expire * 60 * 1000}));\r\n    const result = await request({\r\n      path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions?fields=revisions(id)`\r\n    });\r\n    for (let i = 1; i < result.revisions.length; i++) {\r\n      const revId = result.revisions[i].id;\r\n      if (revId === headRevisionId) {\r\n        // success\r\n        lockRev = headRevisionId;\r\n        return;\r\n      }\r\n      const rev = JSON.parse(await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions/${revId}?alt=media`\r\n      }));\r\n      if (rev.expire > Date.now()) {\r\n        // failed, delete the lock\r\n        await revDelete(lock.id, headRevisionId);\r\n        throw new LockError(rev.expire);\r\n      }\r\n      // delete outdated lock\r\n      await revDelete(lock.id, revId);\r\n    }\r\n    throw new Error(\"cannot find lock revision\");\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    await revDelete(lock.id, lockRev);\r\n    lockRev = null;\r\n  }\r\n  \r\n  async function queryList(path, onPage) {\r\n    path = \"https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&fields=nextPageToken,files(id,name,headRevisionId)\" + (path ? \"&\" + path : \"\");\r\n    let result = await request({path});\r\n    onPage(result);\r\n    while (result.nextPageToken) {\r\n      result = await request({path: `${path}&pageToken=${result.nextPageToken}`});\r\n      onPage(result);\r\n    }\r\n  }\r\n  \r\n  async function queryPatch(id, text) {\r\n    return await request({\r\n      method: \"PATCH\",\r\n      path: `https://www.googleapis.com/upload/drive/v3/files/${id}?uploadType=media&fields=headRevisionId`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: text\r\n    });\r\n  }\r\n  \r\n  async function updateMeta(query) {\r\n    if (query) {\r\n      query = `q=${encodeURIComponent(query)}`;\r\n    }\r\n    await queryList(query, result => {\r\n      for (const file of result.files) {\r\n        fileMetaCache.set(file.name, file);\r\n      }\r\n    });\r\n  }\r\n  \r\n  async function init() {\r\n    await updateMeta();\r\n    if (!fileMetaCache.has(\"lock.json\")) {\r\n      await post(\"lock.json\", \"{}\");\r\n    }\r\n    if (!fileMetaCache.has(\"meta.json\")) {\r\n      await post(\"meta.json\", \"{}\");\r\n    }\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: this only works if file is a single dir\r\n    // FIXME: this only works if the list method is called right after init, use\r\n    // queryList instead?\r\n    return [...fileMetaCache.values()]\r\n      .filter(f => f.name.startsWith(file + \"/\"))\r\n      .map(f => f.name.split(\"/\")[1]);\r\n  }\r\n  \r\n  async function get(file) {\r\n    let meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      await updateMeta(`name = '${file}'`);\r\n      meta = fileMetaCache.get(file);\r\n      if (!meta) {\r\n        throw new RequestError(`metaCache doesn't contain ${file}`, null, \"ENOENT\");\r\n      }\r\n    }\r\n    try {\r\n      return await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}?alt=media`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    if (!fileMetaCache.has(file)) {\r\n      return await post(file, data);\r\n    }\r\n    const meta = fileMetaCache.get(file);\r\n    const result = await queryPatch(meta.id, data);\r\n    meta.headRevisionId = result.headRevisionId;\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    const body = new FormData;\r\n    const meta = {\r\n      name: file,\r\n      parents: [\"appDataFolder\"]\r\n    };\r\n    body.append(\"metadata\", new Blob([JSON.stringify(meta)], {type: \"application/json; charset=UTF-8\"}));\r\n    body.append(\"media\", new Blob([data], {type: \"text/plain\"}));\r\n    const result = await request({\r\n      method: \"POST\",\r\n      path: \"https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,headRevisionId\",\r\n      body\r\n    });\r\n    fileMetaCache.set(result.name, result);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    const meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      return;\r\n    }\r\n    try {\r\n      await request({\r\n        method: \"DELETE\",\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","const {createLock} = require(\"@eight04/read-write-lock\");\r\nconst {LockError} = require(\"./lock\");\r\nconst {delay, debounced} = require(\"./util\");\r\n\r\nfunction buildDrive(_drive) {\r\n  const drive = Object.create(_drive);\r\n  drive.get = async path => JSON.parse(await _drive.get(path));\r\n  drive.put = async (path, data) => await _drive.put(path, JSON.stringify(data));\r\n  drive.post = async (path, data) => await _drive.post(path, JSON.stringify(data));\r\n  drive.isInit = false;\r\n  \r\n  if (!drive.acquireLock) {\r\n    drive.acquireLock = acquireLock;\r\n    drive.releaseLock = releaseLock;\r\n  }\r\n  \r\n  if (!drive.getMeta) {\r\n    drive.getMeta = getMeta;\r\n    drive.putMeta = putMeta;\r\n  }\r\n  \r\n  if (!drive.peekChanges) {\r\n    drive.peekChanges = peekChanges;\r\n  }\r\n  \r\n  return drive;\r\n  \r\n  async function acquireLock(expire) {\r\n    try {\r\n      await this.post(\"lock.json\", {expire: Date.now() + expire * 60 * 1000});\r\n    } catch (err) {\r\n      if (err.code !== \"EEXIST\") {\r\n        throw err;\r\n      }\r\n      const data = await this.get(\"lock.json\");\r\n      if (Date.now() > data.expire) {\r\n        // FIXME: this may delete a different lock created by other instances\r\n        await this.delete(\"lock.json\");\r\n        throw new Error(\"Found expired lock, please try again\");\r\n      }\r\n      throw new LockError(data.expire);\r\n    }\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    await this.delete(\"lock.json\");\r\n  }\r\n  \r\n  async function getMeta() {\r\n    try {\r\n      return await this.get(\"meta.json\");\r\n    } catch (err) {\r\n      if (err.code === \"ENOENT\" || err.code === 404) {\r\n        return {};\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function putMeta(data) {\r\n    await this.put(\"meta.json\", data);\r\n  }\r\n  \r\n  async function peekChanges(oldMeta) {\r\n    const newMeta = await this.getMeta();\r\n    return newMeta.lastChange !== oldMeta.lastChange;\r\n  }\r\n}\r\n\r\nfunction dbToCloud({\r\n  onGet,\r\n  onPut,\r\n  onDelete,\r\n  onFirstSync,\r\n  onWarn = console.error,\r\n  onProgress,\r\n  compareRevision,\r\n  getState,\r\n  setState,\r\n  lockExpire = 60,\r\n  retryMaxAttempts = 5,\r\n  retryExp = 1.5,\r\n  retryDelay = 10\r\n}) {\r\n  let drive;\r\n  let state;\r\n  let meta;\r\n  const changeCache = new Map;\r\n  const saveState = debounced(() => setState(drive, state));\r\n  const revisionCache = new Map;\r\n  const lock = createLock();\r\n  return {\r\n    use,\r\n    init,\r\n    uninit,\r\n    put,\r\n    delete: delete_,\r\n    syncNow,\r\n    drive: () => drive,\r\n    isInit: () => Boolean(state && state.enabled)\r\n  };\r\n  \r\n  function use(newDrive) {\r\n    drive = buildDrive(newDrive);\r\n  }\r\n  \r\n  function init() {\r\n    return lock.write(async () => {\r\n      if (state && state.enabled) {\r\n        return;\r\n      }\r\n      if (!drive) {\r\n        throw new Error(\"cloud drive is undefined\");\r\n      }\r\n      \r\n      state = await getState(drive) || {};\r\n      state.enabled = true;\r\n      if (!state.queue) {\r\n        state.queue = [];\r\n      }\r\n    });\r\n  }\r\n  \r\n  function uninit() {\r\n    return lock.write(async () => {\r\n      if (!state || !state.enabled) {\r\n        return;\r\n      }\r\n      state = meta = null;\r\n      changeCache.clear();\r\n      revisionCache.clear();\r\n      if (drive.uninit && drive.isInit) {\r\n        await drive.uninit();\r\n        drive.isInit = false;\r\n      }\r\n      await saveState();\r\n    });\r\n  }\r\n  \r\n  async function syncPull() {\r\n    meta = await drive.getMeta();\r\n    if (!meta.lastChange || meta.lastChange === state.lastChange) {\r\n      // nothing changes\r\n      return;\r\n    }\r\n    let changes = [];\r\n    if (!state.lastChange) {\r\n      // pull everything\r\n      changes = (await drive.list(\"docs\"))\r\n        .map(name => ({action: 'put', _id: name.slice(0, -5)}));\r\n    } else {\r\n      const end = Math.floor((meta.lastChange - 1) / 100); // inclusive end\r\n      let i = Math.floor(state.lastChange / 100);\r\n      while (i <= end) {\r\n        const newChanges = await drive.get(`changes/${i}.json`);\r\n        changeCache.set(i, newChanges);\r\n        changes = changes.concat(newChanges);\r\n        i++;\r\n      }\r\n      changes = changes.slice(state.lastChange % 100);\r\n    }\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    let loaded = 0;\r\n    for (const [id, change] of idx) {\r\n      let doc, _rev;\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'pull',\r\n          total: idx.size,\r\n          loaded,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await onDelete(id, change._rev);\r\n      } else if (change.action === \"put\") {\r\n        try {\r\n          ({doc, _rev} = await drive.get(`docs/${id}.json`));\r\n        } catch (err) {\r\n          if (err.code === \"ENOENT\" || err.code === 404) {\r\n            onWarn(`Cannot find ${id}. Is it deleted without updating the history?`);\r\n            loaded++;\r\n            continue;\r\n          }\r\n          throw err;\r\n        }\r\n        await onPut(doc);\r\n      }\r\n      // record the remote revision\r\n      const rev = change._rev || _rev;\r\n      if (rev) {\r\n        revisionCache.set(id, rev);\r\n      }\r\n      loaded++;\r\n    }\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function syncPush() {\r\n    if (!state.queue.length) {\r\n      // nothing to push\r\n      return;\r\n    }\r\n    // snapshot\r\n    const changes = state.queue.slice();\r\n\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    // drop outdated change\r\n    const newChanges = [];\r\n    for (const change of idx.values()) {\r\n      // FIXME: is it safe to assume that the local doc is newer when\r\n      // remoteRev is undefined?\r\n      const remoteRev = revisionCache.get(change._id);\r\n      if (remoteRev !== undefined && compareRevision(change._rev, remoteRev) <= 0) {\r\n        continue;\r\n      }\r\n      newChanges.push(change);\r\n    }\r\n    // FIXME: there should be no need to push data when !newChanges.length\r\n    \r\n    // start pushing\r\n    let loaded = 0;\r\n    for (const change of newChanges) {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'push',\r\n          loaded,\r\n          total: newChanges.length,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await drive.delete(`docs/${change._id}.json`);\r\n      } else if (change.action === \"put\") {\r\n        const doc = await onGet(change._id, change._rev);\r\n        await drive.put(`docs/${change._id}.json`, {doc, _rev: change._rev});\r\n      }\r\n      revisionCache.set(change._id, change._rev);\r\n      loaded++;\r\n    }\r\n    \r\n    // push changes\r\n    let lastChanges;\r\n    let index;\r\n    // meta is already pulled in syncPull\r\n    if (meta.lastChange) {\r\n      index = Math.floor(meta.lastChange / 100);\r\n      const len = meta.lastChange % 100;\r\n      lastChanges = len ?\r\n        changeCache.get(index) || await drive.get(`changes/${index}.json`) :\r\n        [];\r\n      // it is possible that JSON data contains more records defined by\r\n      // meta.lastChange\r\n      lastChanges = lastChanges.slice(0, len).concat(newChanges);\r\n    } else {\r\n      // first sync\r\n      index = 0;\r\n      lastChanges = newChanges;\r\n    }\r\n    \r\n    for (let i = 0; i * 100 < lastChanges.length; i++) {\r\n      const window = lastChanges.slice(i * 100, (i + 1) * 100);\r\n      await drive.put(`changes/${index + i}.json`, window);\r\n      changeCache.set(index + i, window);\r\n    }\r\n    meta.lastChange = (meta.lastChange || 0) + newChanges.length;\r\n    await drive.putMeta(meta);\r\n    \r\n    state.queue = state.queue.slice(changes.length);\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function sync() {\r\n    let tried = 0;\r\n    let wait = retryDelay;\r\n    let lastErr;\r\n    while (true) { // eslint-disable-line no-constant-condition\r\n      try {\r\n        await drive.acquireLock(lockExpire);\r\n        break;\r\n      } catch (err) {\r\n        if (err.name !== \"LockError\") {\r\n          throw err;\r\n        }\r\n        lastErr = err;\r\n      }\r\n      tried++;\r\n      if (tried >= retryMaxAttempts) {\r\n        throw lastErr;\r\n      }\r\n      await delay(wait * 1000);\r\n      wait *= retryExp;\r\n    }\r\n    try {\r\n      await syncPull();\r\n      await syncPush();\r\n    } finally {\r\n      await drive.releaseLock();\r\n    }\r\n  }\r\n  \r\n  function syncNow(peek) {\r\n    return lock.write(async () => {\r\n      if (!state || !state.enabled) {\r\n        throw new Error(\"Cannot sync now, the sync is not enabled\");\r\n      }\r\n      if (drive.init && !drive.isInit) {\r\n        await drive.init();\r\n        drive.isInit = true;\r\n      }\r\n      if (state.lastChange == null) {\r\n        await onFirstSync();\r\n      }\r\n      await _syncNow(peek);\r\n    });\r\n  }\r\n  \r\n  async function _syncNow(peek = true) {\r\n    if (onProgress) {\r\n      onProgress({\r\n        phase: 'start'\r\n      });\r\n    }\r\n    try {\r\n      if (!state.queue.length && peek && meta) {\r\n        const changed = await drive.peekChanges(meta);\r\n        if (!changed) {\r\n          return;\r\n        }\r\n      }\r\n      await sync();\r\n    } finally {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'end'\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  function put(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"put\"\r\n    });\r\n    saveState();\r\n  }\r\n  \r\n  function delete_(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"delete\"\r\n    });\r\n    saveState();\r\n  }\r\n}\r\n\r\nmodule.exports = {dbToCloud};\r\n"],"names":["createLock","maxActiveReader","Infinity","firstTask","lastTask","activeReader","self","read","fn","que","write","length","block","task","prev","next","q","defer","q2","createTask","deque","promise","o","Promise","resolve","reject","result","err","onDone","then","_onDone","pending","afterDone","LockError","Error","constructor","expire","Date","toLocaleString","name","captureStackTrace","this","debounced","timer","clearTimeout","setTimeout","run","delay","time","percentToByte","btoa","encodeURIComponent","byteToPercent","b","charCodeAt","decode","decodeURIComponent","Array","from","atob","str","join","RequestError","message","origin","code","status","createRequest","fetch","cooldown","getAccessToken","username","password","lock","basicAuth","base64","args","done","doRequest","method","path","contentType","_headers","headers","format","raw","Object","assign","res","ok","retry","get","Number","text","resContentType","test","json","dirname","dir","replace","arrayify","isArray","xmlToJSON","node","children","prototype","filter","call","childNodes","i","nodeType","textContent","c","cResult","localName","push","list","userAgent","owner","repo","global","request","shaCache","Map","put","post","file","data","delete","requestAPI","names","item","set","sha","content","overwrite","params","has","body","JSON","stringify","retried","includes","requestRPC","entries","entry","has_more","cursor","stringifyParams","obj","URLSearchParams","toString","mode","autorename","mute","query","files","value","map","concat","FormData","Blob","fileMetaCache","lockRev","init","acquireLock","releaseLock","revDelete","fileId","revId","headRevisionId","queryPatch","id","now","revisions","rev","parse","queryList","onPage","nextPageToken","updateMeta","values","f","startsWith","split","meta","parents","append","type","url","DOMParser","endsWith","requestDAV","parseFromString","error","multistatus","response","r","href","propstat","some","s","prop","resourcetype","undefined","collection","base","URL","slice","withDir","cb","onGet","onPut","onDelete","onFirstSync","onWarn","console","onProgress","compareRevision","getState","setState","lockExpire","retryMaxAttempts","retryExp","retryDelay","drive","state","changeCache","saveState","revisionCache","use","newDrive","_drive","create","isInit","getMeta","putMeta","peekChanges","oldMeta","lastChange","buildDrive","enabled","queue","uninit","clear","_id","_rev","action","syncNow","peek","_syncNow","Boolean","syncPull","changes","end","Math","floor","newChanges","idx","change","loaded","doc","phase","total","size","syncPush","remoteRev","lastChanges","index","len","window","sync","lastErr","tried","wait"],"mappings":"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"}