{"version":3,"file":"db-to-cloud.min.js","sources":["../node_modules/@eight04/read-write-lock/index.js","../lib/db-to-cloud.js","../node_modules/universal-base64/dist/browser.js","../lib/request.js","../lib/drive/github.js","../lib/drive/dropbox.js","../lib/drive/onedrive.js","../lib/drive/google.js"],"sourcesContent":["function createLock({maxActiveReader = Infinity} = {}) {\r\n  let firstTask;\r\n  let lastTask;\r\n  let activeReader = 0;\r\n  const self = {\r\n    read: fn => que(fn, false),\r\n    write: fn => que(fn, true),\r\n    length: 0\r\n  };\r\n  return self;\r\n  \r\n  function que(fn, block) {\r\n    const task = createTask({fn, block});\r\n    if (!lastTask) {\r\n      firstTask = lastTask = task;\r\n    } else {\r\n      lastTask.next = task;\r\n      task.prev = lastTask;\r\n      lastTask = task;\r\n      if (!firstTask) {\r\n        firstTask = lastTask;\r\n      }\r\n    }\r\n    self.length++;\r\n    deque();\r\n    return task.q.promise;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n  \r\n  function createTask({\r\n    fn,\r\n    block = false,\r\n    prev,\r\n    next,\r\n    q = defer(),\r\n    q2 = fn.length ? defer() : null\r\n  }) {\r\n    return {fn, block, prev, next, q, q2};\r\n  }\r\n  \r\n  function deque() {\r\n    const task = firstTask;\r\n    if (\r\n      !task ||\r\n      task.block && task.prev ||\r\n      task.prev && task.prev.block ||\r\n      activeReader >= maxActiveReader\r\n    ) {\r\n      return;\r\n    }\r\n    if (!task.block) {\r\n      activeReader++;\r\n    }\r\n    firstTask = task.next;\r\n    let result;\r\n    try {\r\n      result = task.fn(task.q2 && task.q2.resolve);\r\n    } catch (err) {\r\n      task.q.reject(err);\r\n      // auto release with sync error\r\n      // q2 is useless in this case\r\n      onDone();\r\n      return;\r\n    }\r\n    if (task.q2) {\r\n      task.q2.promise.then(_onDone);\r\n    }\r\n    if (result && result.then) {\r\n      const pending = result.then(task.q.resolve, task.q.reject);\r\n      if (!task.q2) {\r\n        pending.then(onDone);\r\n      }\r\n    } else {\r\n      task.q.resolve(result);\r\n      if (!task.q2) {\r\n        // it's a sync function and you don't want to release it manually, why\r\n        // do you need a lock?\r\n        onDone();\r\n        return;\r\n      }\r\n    }\r\n    deque();\r\n    \r\n    function onDone() {\r\n      _onDone();\r\n    }\r\n    \r\n    function _onDone(afterDone) {\r\n      if (task.prev) {\r\n        task.prev.next = task.next;\r\n      }\r\n      if (task.next) {\r\n        task.next.prev = task.prev;\r\n      }\r\n      if (lastTask === task) {\r\n        lastTask = task.prev;\r\n      }\r\n      if (!task.block) {\r\n        activeReader--;\r\n      }\r\n      self.length--;\r\n      if (afterDone) {\r\n        afterDone();\r\n      }\r\n      deque();\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLockPool(options) {\r\n  const locks = new Map; // scope -> lock\r\n  return {\r\n    read: (scope, fn) => op(scope, fn, \"read\"),\r\n    write: (scope, fn) => op(scope, fn, \"write\"),\r\n    locks\r\n  };\r\n  \r\n  async function op(scopeIter, fn, opType) {\r\n    // FIXME: dead lock if there are duplicated scopes?\r\n    const scopes = [];\r\n    const acquiring = [];\r\n    for (const scope of scopeIter) {\r\n      let lock = locks.get(scope);\r\n      if (!lock) {\r\n        lock = createLock(options);\r\n        locks.set(scope, lock);\r\n      }\r\n      const o = {\r\n        lock,\r\n        scope,\r\n        relase: null\r\n      };\r\n      acquiring.push(lock[opType](release => {\r\n        o.release = release;\r\n      }));\r\n      scopes.push(o);\r\n    }\r\n    await Promise.all(acquiring);\r\n    let result;\r\n    try {\r\n      result = fn(fn.length && onDone);\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n    if (result && result.then) {\r\n      if (!fn.length) {\r\n        result.then(onDone, onDone);\r\n      }\r\n      return await result;\r\n    }\r\n    if (!fn.length) {\r\n      onDone();\r\n    }\r\n    return result;\r\n    \r\n    function onDone() {\r\n      for (const scope of scopes) {\r\n        scope.release(() => {\r\n          if (!scope.lock.length) {\r\n            locks.delete(scope.scope);\r\n          }\r\n        });\r\n      }\r\n      scopes.length = 0;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  createLock,\r\n  createLockPool\r\n};\r\n","const {createLock} = require(\"@eight04/read-write-lock\");\r\n\r\nfunction debounced(fn) {\r\n  let timer = 0;\r\n  let q;\r\n  return () => {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    timer = setTimeout(run);\r\n    if (!q) {\r\n      q = defer();\r\n    }\r\n    return q.promise;\r\n  };\r\n  \r\n  function run() {\r\n    Promise.resolve(fn())\r\n      .then(q.resolve, q.reject);\r\n    timer = 0;\r\n    q = null;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n}\r\n\r\nfunction buildDrive(_drive) {\r\n  const drive = Object.create(_drive);\r\n  drive.get = async path => JSON.parse(await _drive.get(path));\r\n  drive.put = async (path, data) => await _drive.put(path, JSON.stringify(data));\r\n  drive.post = async (path, data) => await _drive.post(path, JSON.stringify(data));\r\n  \r\n  if (!drive.acquireLock) {\r\n    drive.acquireLock = acquireLock;\r\n    drive.releaseLock = releaseLock;\r\n  }\r\n  \r\n  if (!drive.getMeta) {\r\n    drive.getMeta = getMeta;\r\n    drive.putMeta = putMeta;\r\n  }\r\n  \r\n  if (!drive.peekChanges) {\r\n    drive.peekChanges = peekChanges;\r\n  }\r\n  \r\n  return drive;\r\n  \r\n  async function acquireLock(expire) {\r\n    try {\r\n      await this.post(\"lock.json\", {expire: Date.now() + expire * 60 * 1000});\r\n    } catch (err) {\r\n      if (err.code === \"EEXIST\") {\r\n        const data = await this.get(\"lock.json\");\r\n        if (Date.now() > data.expire) {\r\n          await this.delete(\"lock.json\");\r\n        }\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    await this.delete(\"lock.json\");\r\n  }\r\n  \r\n  async function getMeta() {\r\n    try {\r\n      return await this.get(\"meta.json\");\r\n    } catch (err) {\r\n      if (err.code === \"ENOENT\" || err.code === 404) {\r\n        return {};\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function putMeta(data) {\r\n    await this.put(\"meta.json\", data);\r\n  }\r\n  \r\n  async function peekChanges(oldMeta) {\r\n    const newMeta = await this.getMeta();\r\n    return newMeta.lastChange !== oldMeta.lastChange;\r\n  }\r\n}\r\n\r\nfunction dbToCloud({\r\n  onGet,\r\n  onPut,\r\n  onDelete,\r\n  onFirstSync,\r\n  onWarn = console.error,\r\n  onProgress,\r\n  compareRevision,\r\n  getState,\r\n  setState,\r\n  lockExpire = 60\r\n}) {\r\n  let drive;\r\n  let state;\r\n  let meta;\r\n  const changeCache = new Map;\r\n  const saveState = debounced(() => setState(drive, state));\r\n  const revisionCache = new Map;\r\n  const lock = createLock();\r\n  return {use, start, stop, put, delete: delete_, syncNow, drive: () => drive};\r\n  \r\n  function use(newDrive) {\r\n    drive = buildDrive(newDrive);\r\n  }\r\n  \r\n  async function start() {\r\n    if (state && state.enabled) {\r\n      return;\r\n    }\r\n    if (!drive) {\r\n      throw new Error(\"cloud drive is undefined\");\r\n    }\r\n    if (drive.init) {\r\n      await drive.init();\r\n    }\r\n    \r\n    state = await getState(drive) || {};\r\n    state.enabled = true;\r\n    if (!state.queue) {\r\n      state.queue = [];\r\n    }\r\n    if (state.lastChange == null) {\r\n      await onFirstSync();\r\n    }\r\n    await syncNow();\r\n  }\r\n  \r\n  async function stop() {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.enabled = false;\r\n    await lock.write(async () => {\r\n      if (drive.uninit) {\r\n        await drive.uninit();\r\n      }\r\n      await saveState();\r\n    });\r\n  }\r\n  \r\n  async function syncPull() {\r\n    meta = await drive.getMeta();\r\n    if (!meta.lastChange || meta.lastChange === state.lastChange) {\r\n      // nothing changes\r\n      return;\r\n    }\r\n    let changes = [];\r\n    if (!state.lastChange) {\r\n      // pull everything\r\n      changes = (await drive.list(\"docs\"))\r\n        .map(name => ({action: 'put', _id: name.slice(0, -5)}));\r\n    } else {\r\n      const end = Math.floor((meta.lastChange - 1) / 100); // inclusive end\r\n      let i = Math.floor(state.lastChange / 100);\r\n      while (i <= end) {\r\n        const newChanges = await drive.get(`changes/${i}.json`);\r\n        changeCache.set(i, newChanges);\r\n        changes = changes.concat(newChanges);\r\n        i++;\r\n      }\r\n      changes = changes.slice(state.lastChange % 100);\r\n    }\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    let loaded = 0;\r\n    for (const [id, change] of idx) {\r\n      let doc, _rev;\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'pull',\r\n          total: idx.size,\r\n          loaded,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await onDelete(id, change._rev);\r\n      } else if (change.action === \"put\") {\r\n        try {\r\n          ({doc, _rev} = await drive.get(`docs/${id}.json`));\r\n        } catch (err) {\r\n          if (err.code === \"ENOENT\" || err.code === 404) {\r\n            onWarn(`Cannot find ${id}. Is it deleted without updating the history?`);\r\n            loaded++;\r\n            continue;\r\n          }\r\n          throw err;\r\n        }\r\n        await onPut(doc);\r\n      }\r\n      // record the remote revision\r\n      const rev = change._rev || _rev;\r\n      if (rev) {\r\n        revisionCache.set(id, rev);\r\n      }\r\n      loaded++;\r\n    }\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function syncPush() {\r\n    if (!state.queue.length) {\r\n      // nothing to push\r\n      return;\r\n    }\r\n    // snapshot\r\n    const changes = state.queue.slice();\r\n\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    // drop outdated change\r\n    const newChanges = [];\r\n    for (const change of idx.values()) {\r\n      // FIXME: is it safe to assume that the local doc is newer when\r\n      // remoteRev is undefined?\r\n      const remoteRev = revisionCache.get(change._id);\r\n      if (remoteRev !== undefined && compareRevision(change._rev, remoteRev) <= 0) {\r\n        continue;\r\n      }\r\n      newChanges.push(change);\r\n    }\r\n    // FIXME: there should be no need to push data when !newChanges.length\r\n    \r\n    // start pushing\r\n    let loaded = 0;\r\n    for (const change of newChanges) {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'push',\r\n          loaded,\r\n          total: newChanges.length,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await drive.delete(`docs/${change._id}.json`);\r\n      } else if (change.action === \"put\") {\r\n        const doc = await onGet(change._id, change._rev);\r\n        await drive.put(`docs/${change._id}.json`, {doc, _rev: change._rev});\r\n      }\r\n      revisionCache.set(change._id, change._rev);\r\n      loaded++;\r\n    }\r\n    \r\n    // push changes\r\n    let lastChanges;\r\n    let index;\r\n    // meta is already pulled in syncPull\r\n    if (meta.lastChange) {\r\n      index = Math.floor(meta.lastChange / 100);\r\n      const len = meta.lastChange % 100;\r\n      lastChanges = len ?\r\n        changeCache.get(index) || await drive.get(`changes/${index}.json`) :\r\n        [];\r\n      // it is possible that JSON data contains more records defined by\r\n      // meta.lastChange\r\n      lastChanges = lastChanges.slice(0, len).concat(newChanges);\r\n    } else {\r\n      // first sync\r\n      index = 0;\r\n      lastChanges = newChanges;\r\n    }\r\n    \r\n    for (let i = 0; i * 100 < lastChanges.length; i++) {\r\n      const window = lastChanges.slice(i * 100, (i + 1) * 100);\r\n      await drive.put(`changes/${index + i}.json`, window);\r\n      changeCache.set(index + i, window);\r\n    }\r\n    meta.lastChange = (meta.lastChange || 0) + newChanges.length;\r\n    await drive.putMeta(meta);\r\n    \r\n    state.queue = state.queue.slice(changes.length);\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function sync() {\r\n    await drive.acquireLock(lockExpire);\r\n    try {\r\n      await syncPull();\r\n      await syncPush();\r\n    } finally {\r\n      await drive.releaseLock();\r\n    }\r\n  }\r\n  \r\n  async function syncNow(peek = true) {\r\n    if (!state || !state.enabled) {\r\n      throw new Error(\"Cannot sync now, the sync is not enabled\");\r\n    }\r\n    await lock.write(async () => {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'start'\r\n        });\r\n      }\r\n      try {\r\n        if (!state.queue.length && peek && meta) {\r\n          const changed = await drive.peekChanges(meta);\r\n          if (!changed) {\r\n            return;\r\n          }\r\n        }\r\n        await sync();\r\n      } finally {\r\n        if (onProgress) {\r\n          onProgress({\r\n            phase: 'end'\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n  \r\n  function put(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"put\"\r\n    });\r\n    saveState();\r\n  }\r\n  \r\n  function delete_(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"delete\"\r\n    });\r\n    saveState();\r\n  }\r\n}\r\n\r\nmodule.exports = {dbToCloud};\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction percentToByte(p) {\n    return String.fromCharCode(parseInt(p.slice(1), 16));\n}\nfunction encode(str) {\n    return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));\n}\nexports.encode = encode;\nfunction byteToPercent(b) {\n    return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`;\n}\nfunction decode(str) {\n    return decodeURIComponent(Array.from(atob(str), byteToPercent).join(\"\"));\n}\nexports.decode = decode;\n//# sourceMappingURL=browser.js.map","const {createLock} = require(\"@eight04/read-write-lock\");\r\n\r\nclass RequestError extends Error {\r\n  constructor(message, origin, code = origin && origin.status) {\r\n    super(message);\r\n    this.code = code;\r\n    this.origin = origin;\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, RequestError);\r\n    }\r\n  }\r\n}\r\n\r\nfunction delay(time) {\r\n  return new Promise(resolve => setTimeout(resolve, time));\r\n}\r\n\r\nfunction createRequest({fetch, cooldown = 0, getAccessToken}) {\r\n  const lock = createLock();\r\n  return args => {\r\n    return lock.write(async done => {\r\n      try {\r\n        return await doRequest(args);\r\n      } finally {\r\n        if (!cooldown || !args.method || args.method === \"GET\") {\r\n          done();\r\n        } else {\r\n          setTimeout(done, cooldown);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  \r\n  async function doRequest({path, contentType, headers: _headers, format, ...args}) {\r\n    const headers = {\r\n      \"Authorization\": `Bearer ${await getAccessToken()}`\r\n    };\r\n    if (contentType) {\r\n      headers[\"Content-Type\"] = contentType;\r\n    }\r\n    Object.assign(headers, _headers);\r\n    while (true) { // eslint-disable-line no-constant-condition\r\n      const res = await fetch(path, {\r\n        headers,\r\n        ...args\r\n      });\r\n      if (!res.ok) {\r\n        const retry = res.headers.get(\"Retry-After\");\r\n        if (retry) {\r\n          const time = Number(retry);\r\n          if (time) {\r\n            await delay(time * 1000);\r\n            continue;\r\n          }\r\n        }\r\n        const text = await res.text();\r\n        throw new RequestError(`failed to fetch [${res.status}]: ${text}`, res);\r\n      }\r\n      if (format) {\r\n        return await res[format]();\r\n      }\r\n      const resContentType = res.headers.get(\"Content-Type\");\r\n      if (/application\\/json/.test(resContentType)) {\r\n        return await res.json();\r\n      }\r\n      return await res.text();\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {createRequest, RequestError};\r\n","/* global self */\r\nconst base64 = require(\"universal-base64\");\r\n\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  userAgent = \"db-to-cloud\",\r\n  owner,\r\n  repo,\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken, cooldown: 1000});\r\n  const shaCache = new Map;\r\n  return {\r\n    name: \"github\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    shaCache\r\n  };\r\n  \r\n  function requestAPI(args) {\r\n    if (!args.headers) {\r\n      args.headers = {};\r\n    }\r\n    if (!args.headers[\"User-Agent\"]) {\r\n      args.headers[\"User-Agent\"] = userAgent;\r\n    }\r\n    if (!args.headers[\"Accept\"]) {\r\n      args.headers[\"Accept\"] = \"application/vnd.github.v3+json\";\r\n    }\r\n    args.path = `https://api.github.com${args.path}`;\r\n    return request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the Git Trees API.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    const names = [];\r\n    for (const item of result) {\r\n      names.push(item.name);\r\n      shaCache.set(item.path, item.sha);\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  async function get(file) {\r\n    // FIXME: This API supports files up to 1 megabyte in size.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    shaCache.set(result.path, result.sha);\r\n    return base64.decode(result.content);\r\n  }\r\n  \r\n  async function put(file, data, overwrite = true) {\r\n    const params = {\r\n      message: \"\",\r\n      content: base64.encode(data)\r\n    };\r\n    if (overwrite && shaCache.has(file)) {\r\n      params.sha = shaCache.get(file);\r\n    }\r\n    const args = {\r\n      method: \"PUT\",\r\n      path: `/repos/${owner}/${repo}/contents/${file}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(params)\r\n    };\r\n    let retried = false;\r\n    let result;\r\n    while (!result) {\r\n      try {\r\n        result = await requestAPI(args);\r\n      } catch (err) {\r\n        if (err.code !== 422 || !err.message.includes(\"\\\\\\\"sha\\\\\\\" wasn't supplied\")) {\r\n          throw err;\r\n        }\r\n        if (!overwrite || retried) {\r\n          err.code = \"EEXIST\";\r\n          throw err;\r\n        }\r\n        await get(file);\r\n      }\r\n      retried = true;\r\n    }\r\n    shaCache.set(file, result.content.sha);\r\n  }\r\n  \r\n  function post(file, data) {\r\n    return put(file, data, false);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      let sha = shaCache.get(file);\r\n      if (!sha) {\r\n        await get(file);\r\n        sha = shaCache.get(file);\r\n      }\r\n      await requestAPI({\r\n        method: \"DELETE\",\r\n        path: `/repos/${owner}/${repo}/contents/${file}`,\r\n        body: JSON.stringify({\r\n          message: \"\",\r\n          sha\r\n        })\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      // FIXME: do we have to handle 422 errors?\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"dropbox\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  function requestRPC({path, body, ...args}) {\r\n    return request({\r\n      method: \"POST\",\r\n      path: `https://api.dropboxapi.com/2/${path}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(body),\r\n      ...args\r\n    });\r\n  }\r\n  \r\n  async function list(file) {\r\n    const names = [];\r\n    let result = await requestRPC({\r\n      path: \"files/list_folder\",\r\n      body: {\r\n        path: `/${file}`\r\n      }\r\n    });\r\n    for (const entry of result.entries) {\r\n      names.push(entry.name);\r\n    }\r\n    if (!result.has_more) {\r\n      return names;\r\n    }\r\n    while (result.has_more) {\r\n      result = await requestRPC({\r\n        path: \"files/list_folder/continue\",\r\n        body: {\r\n          cursor: result.cursor\r\n        }\r\n      });\r\n      for (const entry of result.entries) {\r\n        names.push(entry.name);\r\n      }\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  function stringifyParams(obj) {\r\n    const params = new URLSearchParams;\r\n    params.set(\"arg\", JSON.stringify(obj));\r\n    return params.toString();\r\n  }\r\n  \r\n  async function get(file) {\r\n    const params = {\r\n      path: `/${file}`\r\n    };\r\n    try {\r\n      return await request({\r\n        path: `https://content.dropboxapi.com/2/files/download?${stringifyParams(params)}`,\r\n        format: \"text\"\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data, mode = \"overwrite\") {\r\n    const params = {\r\n      path: `/${file}`,\r\n      mode,\r\n      autorename: false\r\n    };\r\n    await request({\r\n      path: `https://content.dropboxapi.com/2/files/upload?${stringifyParams(params)}`,\r\n      method: \"POST\",\r\n      contentType: \"application/octet-stream\",\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      return await put(file, data, \"add\");\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"conflict\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await requestRPC({\r\n        path: \"files/delete_v2\",\r\n        body: {\r\n          path: `/${file}`\r\n        }\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"onedrive\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  async function query(args) {\r\n    args.path = `https://graph.microsoft.com/v1.0/me/drive/special/approot${args.path}`;\r\n    return await request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    if (file) {\r\n      file = `:/${file}:`;\r\n    }\r\n    const result = await query({\r\n      path: `${file}/children?select=name`\r\n    });\r\n    return result.value.map(i => i.name);\r\n  }\r\n  \r\n  async function get(file) {\r\n    return await query({\r\n      path: `:/${file}:/content`,\r\n      format: \"text\"\r\n    });\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    await query({\r\n      method: \"PUT\",\r\n      path: `:/${file}:/content`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      await query({\r\n        method: \"PUT\",\r\n        path: `:/${file}:/content?@microsoft.graph.conflictBehavior=fail`,\r\n        headers: {\r\n          \"Content-Type\": \"text/plain\"\r\n        },\r\n        body: data\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"nameAlreadyExists\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await query({\r\n        method: \"DELETE\",\r\n        path: `:/${file}:`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest, RequestError} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\r\n  FormData = (typeof self !== \"undefined\" ? self : global).FormData,\r\n  Blob = (typeof self !== \"undefined\" ? self : global).Blob\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  const fileMetaCache = new Map;\r\n  let lockRev;\r\n  return {\r\n    name: \"google\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    init,\r\n    acquireLock,\r\n    releaseLock,\r\n    fileMetaCache\r\n  };\r\n  \r\n  async function revDelete(fileId, revId) {\r\n    await request({\r\n      method: \"DELETE\",\r\n      path: `https://www.googleapis.com/drive/v3/files/${fileId}/revisions/${revId}`\r\n    });\r\n  }\r\n  \r\n  async function acquireLock(expire) {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    const {headRevisionId} = await queryPatch(lock.id, JSON.stringify({expire: Date.now() + expire * 60 * 1000}));\r\n    const result = await request({\r\n      path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions?fields=revisions(id)`\r\n    });\r\n    for (let i = 1; i < result.revisions.length; i++) {\r\n      const revId = result.revisions[i].id;\r\n      if (revId === headRevisionId) {\r\n        // success\r\n        lockRev = headRevisionId;\r\n        return;\r\n      }\r\n      const rev = JSON.parse(await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions/${revId}?alt=media`\r\n      }));\r\n      if (rev.expire > Date.now()) {\r\n        // failed, delete the lock\r\n        await revDelete(lock.id, headRevisionId);\r\n        throw new RequestError(\"failed to acquire lock\", null, \"EEXIST\");\r\n      }\r\n      // delete outdated lock\r\n      await revDelete(lock.id, revId);\r\n    }\r\n    throw new Error(\"cannot find lock revision\");\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    await revDelete(lock.id, lockRev);\r\n    lockRev = null;\r\n  }\r\n  \r\n  async function queryList(path, onPage) {\r\n    path = \"https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&fields=nextPageToken,files(id,name,headRevisionId)\" + (path ? \"&\" + path : \"\");\r\n    let result = await request({path});\r\n    onPage(result);\r\n    while (result.nextPageToken) {\r\n      result = await request({path: `${path}&pageToken=${result.nextPageToken}`});\r\n      onPage(result);\r\n    }\r\n  }\r\n  \r\n  async function queryPatch(id, text) {\r\n    return await request({\r\n      method: \"PATCH\",\r\n      path: `https://www.googleapis.com/upload/drive/v3/files/${id}?uploadType=media&fields=headRevisionId`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: text\r\n    });\r\n  }\r\n  \r\n  async function updateMeta(query) {\r\n    if (query) {\r\n      query = `q=${encodeURIComponent(query)}`;\r\n    }\r\n    await queryList(query, result => {\r\n      for (const file of result.files) {\r\n        fileMetaCache.set(file.name, file);\r\n      }\r\n    });\r\n  }\r\n  \r\n  async function init() {\r\n    await updateMeta();\r\n    if (!fileMetaCache.has(\"lock.json\")) {\r\n      await post(\"lock.json\", \"{}\");\r\n    }\r\n    if (!fileMetaCache.has(\"meta.json\")) {\r\n      await post(\"meta.json\", \"{}\");\r\n    }\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: this only works if file is a single dir\r\n    // FIXME: this only works if the list method is called right after init, use\r\n    // queryList instead?\r\n    return [...fileMetaCache.values()]\r\n      .filter(f => f.name.startsWith(file + \"/\"))\r\n      .map(f => f.name.split(\"/\")[1]);\r\n  }\r\n  \r\n  async function get(file) {\r\n    let meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      await updateMeta(`name = '${file}'`);\r\n      meta = fileMetaCache.get(file);\r\n      if (!meta) {\r\n        throw new RequestError(`metaCache doesn't contain ${file}`, null, \"ENOENT\");\r\n      }\r\n    }\r\n    try {\r\n      return await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}?alt=media`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    if (!fileMetaCache.has(file)) {\r\n      return await post(file, data);\r\n    }\r\n    const meta = fileMetaCache.get(file);\r\n    const result = await queryPatch(meta.id, data);\r\n    meta.headRevisionId = result.headRevisionId;\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    const body = new FormData;\r\n    const meta = {\r\n      name: file,\r\n      parents: [\"appDataFolder\"]\r\n    };\r\n    body.append(\"metadata\", new Blob([JSON.stringify(meta)], {type: \"application/json; charset=UTF-8\"}));\r\n    body.append(\"media\", new Blob([data], {type: \"text/plain\"}));\r\n    const result = await request({\r\n      method: \"POST\",\r\n      path: \"https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,headRevisionId\",\r\n      body\r\n    });\r\n    fileMetaCache.set(result.name, result);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    const meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      return;\r\n    }\r\n    try {\r\n      await request({\r\n        method: \"DELETE\",\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n"],"names":["createLock","maxActiveReader","Infinity","firstTask","lastTask","activeReader","self","read","fn","que","write","length","block","task","prev","next","q","defer","q2","createTask","deque","result","resolve","err","reject","onDone","promise","then","_onDone","pending","afterDone","o","Promise","debounced","timer","clearTimeout","setTimeout","run","percentToByte","p","String","fromCharCode","parseInt","slice","byteToPercent","b","charCodeAt","toString","Object","defineProperty","_module_exports_","value","encode","str","btoa","encodeURIComponent","replace","decode","decodeURIComponent","Array","from","atob","join","RequestError","Error","constructor","message","origin","code","status","captureStackTrace","this","delay","time","createRequest","fetch","cooldown","getAccessToken","lock","args","done","doRequest","method","path","contentType","_headers","headers","format","assign","res","ok","retry","get","Number","text","resContentType","test","json","userAgent","owner","repo","global","request","shaCache","Map","name","put","post","file","data","delete","list","requestAPI","names","item","push","set","sha","base64","content","overwrite","params","has","body","JSON","stringify","retried","includes","requestRPC","entries","entry","has_more","cursor","stringifyParams","obj","URLSearchParams","mode","autorename","query","map","i","FormData","Blob","fileMetaCache","lockRev","init","acquireLock","releaseLock","revDelete","fileId","revId","expire","headRevisionId","queryPatch","id","Date","now","revisions","parse","onPage","nextPageToken","updateMeta","queryList","files","values","filter","f","startsWith","split","meta","parents","append","type","onGet","onPut","onDelete","onFirstSync","onWarn","console","error","onProgress","compareRevision","getState","setState","lockExpire","drive","state","changeCache","saveState","revisionCache","use","newDrive","_drive","create","getMeta","putMeta","peekChanges","oldMeta","lastChange","buildDrive","start","stop","_id","_rev","enabled","queue","action","syncNow","uninit","changes","end","Math","floor","newChanges","concat","idx","change","loaded","doc","phase","total","size","rev","remoteRev","undefined","lastChanges","index","len","window","syncPull","syncPush","peek","sync"],"mappings":"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"}