{"version":3,"file":"db-to-cloud.min.js","sources":["../node_modules/@eight04/read-write-lock/index.js","../lib/lock.js","../lib/util.js","../node_modules/universal-base64/dist/browser.js","../lib/request.js","../shim/path.mjs","../lib/drive/webdav.js","../shim/empty.js","../lib/drive/github.js","../lib/drive/dropbox.js","../lib/drive/onedrive.js","../lib/drive/google.js","../lib/db-to-cloud.js"],"sourcesContent":["function createLock({maxActiveReader = Infinity} = {}) {\r\n  let firstTask;\r\n  let lastTask;\r\n  let activeReader = 0;\r\n  const self = {\r\n    read: fn => que(fn, false),\r\n    write: fn => que(fn, true),\r\n    length: 0\r\n  };\r\n  return self;\r\n  \r\n  function que(fn, block) {\r\n    const task = createTask({fn, block});\r\n    if (!lastTask) {\r\n      firstTask = lastTask = task;\r\n    } else {\r\n      lastTask.next = task;\r\n      task.prev = lastTask;\r\n      lastTask = task;\r\n      if (!firstTask) {\r\n        firstTask = lastTask;\r\n      }\r\n    }\r\n    self.length++;\r\n    deque();\r\n    return task.q.promise;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n  \r\n  function createTask({\r\n    fn,\r\n    block = false,\r\n    prev,\r\n    next,\r\n    q = defer(),\r\n    q2 = fn.length ? defer() : null\r\n  }) {\r\n    return {fn, block, prev, next, q, q2};\r\n  }\r\n  \r\n  function deque() {\r\n    const task = firstTask;\r\n    if (\r\n      !task ||\r\n      task.block && task.prev ||\r\n      task.prev && task.prev.block ||\r\n      activeReader >= maxActiveReader\r\n    ) {\r\n      return;\r\n    }\r\n    if (!task.block) {\r\n      activeReader++;\r\n    }\r\n    firstTask = task.next;\r\n    let result;\r\n    try {\r\n      result = task.fn(task.q2 && task.q2.resolve);\r\n    } catch (err) {\r\n      task.q.reject(err);\r\n      // auto release with sync error\r\n      // q2 is useless in this case\r\n      onDone();\r\n      return;\r\n    }\r\n    if (task.q2) {\r\n      task.q2.promise.then(_onDone);\r\n    }\r\n    if (result && result.then) {\r\n      const pending = result.then(task.q.resolve, task.q.reject);\r\n      if (!task.q2) {\r\n        pending.then(onDone);\r\n      }\r\n    } else {\r\n      task.q.resolve(result);\r\n      if (!task.q2) {\r\n        // it's a sync function and you don't want to release it manually, why\r\n        // do you need a lock?\r\n        onDone();\r\n        return;\r\n      }\r\n    }\r\n    deque();\r\n    \r\n    function onDone() {\r\n      _onDone();\r\n    }\r\n    \r\n    function _onDone(afterDone) {\r\n      if (task.prev) {\r\n        task.prev.next = task.next;\r\n      }\r\n      if (task.next) {\r\n        task.next.prev = task.prev;\r\n      }\r\n      if (lastTask === task) {\r\n        lastTask = task.prev;\r\n      }\r\n      if (!task.block) {\r\n        activeReader--;\r\n      }\r\n      self.length--;\r\n      if (afterDone) {\r\n        afterDone();\r\n      }\r\n      deque();\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLockPool(options) {\r\n  const locks = new Map; // scope -> lock\r\n  return {\r\n    read: (scope, fn) => op(scope, fn, \"read\"),\r\n    write: (scope, fn) => op(scope, fn, \"write\"),\r\n    locks\r\n  };\r\n  \r\n  async function op(scopeIter, fn, opType) {\r\n    // FIXME: dead lock if there are duplicated scopes?\r\n    const scopes = [];\r\n    const acquiring = [];\r\n    for (const scope of scopeIter) {\r\n      let lock = locks.get(scope);\r\n      if (!lock) {\r\n        lock = createLock(options);\r\n        locks.set(scope, lock);\r\n      }\r\n      const o = {\r\n        lock,\r\n        scope,\r\n        relase: null\r\n      };\r\n      acquiring.push(lock[opType](release => {\r\n        o.release = release;\r\n      }));\r\n      scopes.push(o);\r\n    }\r\n    await Promise.all(acquiring);\r\n    let result;\r\n    try {\r\n      result = fn(fn.length && onDone);\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n    if (result && result.then) {\r\n      if (!fn.length) {\r\n        result.then(onDone, onDone);\r\n      }\r\n      return await result;\r\n    }\r\n    if (!fn.length) {\r\n      onDone();\r\n    }\r\n    return result;\r\n    \r\n    function onDone() {\r\n      for (const scope of scopes) {\r\n        scope.release(() => {\r\n          if (!scope.lock.length) {\r\n            locks.delete(scope.scope);\r\n          }\r\n        });\r\n      }\r\n      scopes.length = 0;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  createLock,\r\n  createLockPool\r\n};\r\n","class LockError extends Error {\n  constructor(expire) {\n    super(`The database is locked. Will expire at ${new Date(expire).toLocaleString()}`);\n    this.expire = expire;\n    this.name = \"LockError\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, LockError);\n    }\n  }\n}\n\nmodule.exports = {LockError};\n","function debounced(fn) {\n  let timer = 0;\n  let q;\n  return () => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(run);\n    if (!q) {\n      q = defer();\n    }\n    return q.promise;\n  };\n  \n  function run() {\n    Promise.resolve(fn())\n      .then(q.resolve, q.reject);\n    timer = 0;\n    q = null;\n  }\n  \n  function defer() {\n    const o = {};\n    o.promise = new Promise((resolve, reject) => {\n      o.resolve = resolve;\n      o.reject = reject;\n    });\n    return o;\n  }\n}\n\nfunction delay(time) {\n  return new Promise(resolve => setTimeout(resolve, time));\n}\n\nfunction xmlToJSON(node) {\n  // FIXME: xmldom doesn't support children\n  const children = Array.prototype.filter.call(node.childNodes, i => i.nodeType === 1);\n  if (!children.length) {\n    return node.textContent;\n  }\n  \n  const o = {};\n  for (const c of children) {\n    const cResult = xmlToJSON(c);\n    if (!o[c.localName]) {\n      o[c.localName] = cResult;\n    } else if (!Array.isArray(o[c.localName])) {\n      const list = [o[c.localName]];\n      list.push(cResult);\n      o[c.localName] = list;\n    } else {\n      o[c.localName].push(cResult);\n    }\n  }\n  return o;\n}\n\nfunction createXMLParser(DOMParser) {\n  let parser;\n  return function parseXML(text) {\n    if (!parser) {\n      parser = new DOMParser();\n    }\n    const xml = parser.parseFromString(text, \"application/xml\");\n    return xmlToJSON(xml);\n  };\n}\n\nmodule.exports = {debounced, delay, createXMLParser, xmlToJSON};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction percentToByte(p) {\n    return String.fromCharCode(parseInt(p.slice(1), 16));\n}\nfunction encode(str) {\n    return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));\n}\nexports.encode = encode;\nfunction byteToPercent(b) {\n    return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`;\n}\nfunction decode(str) {\n    return decodeURIComponent(Array.from(atob(str), byteToPercent).join(\"\"));\n}\nexports.decode = decode;\n//# sourceMappingURL=browser.js.map","const {createLock} = require(\"@eight04/read-write-lock\");\nconst base64 = require(\"universal-base64\");\n\nconst {delay} = require(\"./util\");\n\nclass RequestError extends Error {\n  constructor(message, origin, code = origin && origin.status) {\n    super(message);\n    this.code = code;\n    this.origin = origin;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RequestError);\n    }\n  }\n}\n\nfunction createRequest({fetch, cooldown = 0, getAccessToken, username, password}) {\n  const lock = createLock();\n  const basicAuth = username || password ?\n    `Basic ${base64.encode(`${username}:${password}`)}` :\n    null;\n  return args => {\n    return lock.write(async done => {\n      try {\n        return await doRequest(args);\n      } finally {\n        if (!cooldown || !args.method || args.method === \"GET\") {\n          done();\n        } else {\n          setTimeout(done, cooldown);\n        }\n      }\n    });\n  };\n  \n  async function doRequest({\n    path,\n    contentType,\n    headers: _headers,\n    format,\n    raw = false,\n    ...args\n  }) {\n    const headers = {};\n    if (getAccessToken) {\n      headers[\"Authorization\"] = `Bearer ${await getAccessToken()}`;\n    }\n    if (basicAuth) {\n      headers[\"Authorization\"] = basicAuth;\n    }\n    if (contentType) {\n      headers[\"Content-Type\"] = contentType;\n    }\n    Object.assign(headers, _headers);\n    while (true) { // eslint-disable-line no-constant-condition\n      // console.log(\"req\", path, args, headers);\n      const res = await fetch(path, {\n        headers,\n        ...args\n      });\n      // console.log(\"res\", path, args, res.status, headers);\n      if (!res.ok) {\n        const retry = res.headers.get(\"Retry-After\");\n        if (retry) {\n          const time = Number(retry);\n          if (time) {\n            await delay(time * 1000);\n            continue;\n          }\n        }\n        const text = await res.text();\n        throw new RequestError(`failed to fetch [${res.status}]: ${text}`, res);\n      }\n      if (raw) {\n        return res;\n      }\n      if (format) {\n        return await res[format]();\n      }\n      const resContentType = res.headers.get(\"Content-Type\");\n      if (/application\\/json/.test(resContentType)) {\n        return await res.json();\n      }\n      return await res.text();\n    }\n  }\n}\n\nmodule.exports = {createRequest, RequestError};\n","export function dirname(path) {\n  const dir = path.replace(/[/\\\\][^/\\\\]+\\/?$/, \"\");\n  if (dir === path) return \".\";\n  return dir;\n}\n\nexport function basename(path) {\n  const match = path.match(/([^/\\\\]+)[/\\\\]*$/);\n  return match ? match[1] : \"\";\n}\n","/* global self */\nconst {dirname, basename} = require(\"path\");\n\nconst {createRequest} = require(\"../request\");\nconst {createXMLParser} = require(\"../util\");\n\nfunction arrayify(o) {\n  return Array.isArray(o) ? o : [o];\n}\n\nfunction createDrive({\n  username,\n  password,\n  url,\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\n  DOMParser = (typeof self !== \"undefined\" ? self : global).DOMParser,\n  parseXML = createXMLParser(DOMParser)\n}) {\n  if (!url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  let lockToken;\n  const request = createRequest({fetch, username, password});\n  return {\n    name: \"webdav\",\n    get,\n    put,\n    post,\n    delete: delete_,\n    list,\n    // acquireLock,\n    // releaseLock\n  };\n  \n  async function requestDAV({path, ...args}) {\n    if (lockToken) {\n      args.headers = args.headers || {};\n      args.headers[\"If\"] = `(${lockToken})`;\n    }\n    const text = await request({\n      path: `${url}${path}`,\n      ...args\n    });\n    if (args.format || typeof text !== \"string\" || !text) return text;\n    const result = await parseXML(text);\n    if (result.error) {\n      throw new Error(`Failed requesting DAV at ${url}${path}: ${JSON.stringify(result.error)}`);\n    }\n    if (result.multistatus) {\n      result.multistatus.response = arrayify(result.multistatus.response);\n      for (const r of result.multistatus.response) {\n        if (r.error) {\n          throw new Error(`Failed requesting DAV at ${url}${path}: ${r.href} ${r.error}`);\n        }\n      }\n    }\n    return result;\n  }\n  \n  async function list(file) {\n    if (!file.endsWith(\"/\")) {\n      file += \"/\";\n    }\n    const result = await requestDAV({\n      method: \"PROPFIND\",\n      path: file,\n      contentType: \"application/xml\",\n      body: \n        `<?xml version=\"1.0\" encoding=\"utf-8\" ?> \n        <propfind xmlns=\"DAV:\">\n          <allprop/>\n        </propfind>`,\n      headers: {\n        \"Depth\": \"1\"\n      }\n    });\n    \n    const files = [];\n    for (const entry of arrayify(result.multistatus.response)) {\n      if (arrayify(entry.propstat).some(s => s.prop.resourcetype && s.prop.resourcetype.collection !== undefined)) {\n        continue;\n      }\n      // FIXME: what is the proper way to get the filename from entry?\n      // NOTE: some servers may treat `@` and `%40` as the same path, we may have to normalize them here and there.\n      const base = `${url}${file}`;\n      const absUrl = new URL(entry.href, base).href;\n      const name = basename(absUrl);\n      files.push(name);\n    }\n    return files;\n  }\n  \n  async function get(file) {\n    return await requestDAV({\n      method: \"GET\",\n      path: file,\n      format: \"text\"\n    });\n  }\n  \n  async function put(file, data) {\n    return await withDir(\n      dirname(file),\n      () => requestDAV({\n        method: \"PUT\",\n        path: file,\n        contentType: \"application/octet-stream\",\n        body: data\n      })\n    );\n  }\n  \n  async function withDir(dir, cb) {\n    try {\n      return await cb();\n    } catch (err) {\n      if (err.code !== 409 && err.code !== 404 || dir === \".\") {\n        throw err;\n      }\n    }\n    await withDir(dirname(dir), () =>\n      requestDAV({\n        method: \"MKCOL\",\n        path: dir\n      })\n    );\n    return await cb();\n  }\n  \n  async function post(file, data) {\n    try {\n      return await withDir(\n        dirname(file),\n        () => requestDAV({\n          method: \"PUT\",\n          path: file,\n          body: data,\n          contentType: \"octet-stream\",\n          headers: {\n            // FIXME: seems webdav-server doesn't support etag, what about others?\n            \"If-None-Match\": \"*\"\n          }\n        })\n      );\n    } catch (err) {\n      if (err.code === 412) {\n        err.code = \"EEXIST\";\n      }\n      throw err;\n    }\n  }\n  \n  async function delete_(file) {\n    // FIXME: support deleting collections?\n    // FIXME: handle errors?\n    try {\n      await requestDAV({\n        method: \"DELETE\",\n        path: file\n      });\n    } catch (err) {\n      if (err.code === 404) return;\n      throw err;\n    }\n  }\n  \n  // async function acquireLock(mins) {\n    // const r = await requestDAV({\n      // method: \"LOCK\",\n      // path: \"\",\n      // body: \n        // `<?xml version=\"1.0\" encoding=\"utf-8\" ?> \n        // <lockinfo xmlns='DAV:'> \n          // <lockscope><exclusive/></lockscope> \n          // <locktype><write/></locktype> \n        // </lockinfo> `,\n      // headers: {\n        // \"Timeout\": `Second-${mins * 60}`\n      // },\n      // raw: true\n    // });\n    // lockToken = r.headers.get(\"Lock-Token\");\n  // }\n  \n  // async function releaseLock() {\n    // await requestDAV({\n      // method: \"UNLOCK\",\n      // path: \"\",\n      // headers: {\n        // \"Lock-Token\": lockToken\n      // }\n    // });\n  // }\n}\n\nmodule.exports = createDrive;\n","module.exports = () => {};\n","/* global self */\nconst base64 = require(\"universal-base64\");\n\nconst {createRequest} = require(\"../request\");\n\nfunction createDrive({\n  userAgent = \"db-to-cloud\",\n  owner,\n  repo,\n  getAccessToken,\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\n}) {\n  const request = createRequest({fetch, getAccessToken, cooldown: 1000});\n  const shaCache = new Map;\n  return {\n    name: \"github\",\n    get,\n    put,\n    post,\n    delete: delete_,\n    list,\n    shaCache\n  };\n  \n  function requestAPI(args) {\n    if (!args.headers) {\n      args.headers = {};\n    }\n    if (!args.headers[\"User-Agent\"]) {\n      args.headers[\"User-Agent\"] = userAgent;\n    }\n    if (!args.headers[\"Accept\"]) {\n      args.headers[\"Accept\"] = \"application/vnd.github.v3+json\";\n    }\n    args.path = `https://api.github.com${args.path}`;\n    return request(args);\n  }\n  \n  async function list(file) {\n    // FIXME: This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the Git Trees API.\n    const result = await requestAPI({\n      path: `/repos/${owner}/${repo}/contents/${file}`\n    });\n    const names = [];\n    for (const item of result) {\n      names.push(item.name);\n      shaCache.set(item.path, item.sha);\n    }\n    return names;\n  }\n  \n  async function get(file) {\n    // FIXME: This API supports files up to 1 megabyte in size.\n    const result = await requestAPI({\n      path: `/repos/${owner}/${repo}/contents/${file}`\n    });\n    shaCache.set(result.path, result.sha);\n    return base64.decode(result.content);\n  }\n  \n  async function put(file, data, overwrite = true) {\n    const params = {\n      message: \"\",\n      content: base64.encode(data)\n    };\n    if (overwrite && shaCache.has(file)) {\n      params.sha = shaCache.get(file);\n    }\n    const args = {\n      method: \"PUT\",\n      path: `/repos/${owner}/${repo}/contents/${file}`,\n      contentType: \"application/json\",\n      body: JSON.stringify(params)\n    };\n    let retried = false;\n    let result;\n    while (!result) {\n      try {\n        result = await requestAPI(args);\n      } catch (err) {\n        if (err.code !== 422 || !err.message.includes(\"\\\\\\\"sha\\\\\\\" wasn't supplied\")) {\n          throw err;\n        }\n        if (!overwrite || retried) {\n          err.code = \"EEXIST\";\n          throw err;\n        }\n        await get(file);\n      }\n      retried = true;\n    }\n    shaCache.set(file, result.content.sha);\n  }\n  \n  function post(file, data) {\n    return put(file, data, false);\n  }\n  \n  async function delete_(file) {\n    try {\n      let sha = shaCache.get(file);\n      if (!sha) {\n        await get(file);\n        sha = shaCache.get(file);\n      }\n      await requestAPI({\n        method: \"DELETE\",\n        path: `/repos/${owner}/${repo}/contents/${file}`,\n        body: JSON.stringify({\n          message: \"\",\n          sha\n        })\n      });\n    } catch (err) {\n      if (err.code === 404) {\n        return;\n      }\n      // FIXME: do we have to handle 422 errors?\n      throw err;\n    }\n  }\n}\n\nmodule.exports = createDrive;\n","/* global self */\nconst {createRequest} = require(\"../request\");\n\nfunction createDrive({\n  getAccessToken,\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\n}) {\n  const request = createRequest({fetch, getAccessToken});\n  return {\n    name: \"dropbox\",\n    get,\n    put,\n    post,\n    delete: delete_,\n    list\n  };\n  \n  function requestRPC({path, body, ...args}) {\n    return request({\n      method: \"POST\",\n      path: `https://api.dropboxapi.com/2/${path}`,\n      contentType: \"application/json\",\n      body: JSON.stringify(body),\n      ...args\n    });\n  }\n  \n  async function list(file) {\n    const names = [];\n    let result = await requestRPC({\n      path: \"files/list_folder\",\n      body: {\n        path: `/${file}`\n      }\n    });\n    for (const entry of result.entries) {\n      names.push(entry.name);\n    }\n    if (!result.has_more) {\n      return names;\n    }\n    while (result.has_more) {\n      result = await requestRPC({\n        path: \"files/list_folder/continue\",\n        body: {\n          cursor: result.cursor\n        }\n      });\n      for (const entry of result.entries) {\n        names.push(entry.name);\n      }\n    }\n    return names;\n  }\n  \n  function stringifyParams(obj) {\n    const params = new URLSearchParams;\n    params.set(\"arg\", JSON.stringify(obj));\n    return params.toString();\n  }\n  \n  async function get(file) {\n    const params = {\n      path: `/${file}`\n    };\n    try {\n      return await request({\n        path: `https://content.dropboxapi.com/2/files/download?${stringifyParams(params)}`,\n        format: \"text\"\n      });\n    } catch (err) {\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\n        err.code = \"ENOENT\";\n      }\n      throw err;\n    }\n  }\n  \n  async function put(file, data, mode = \"overwrite\") {\n    const params = {\n      path: `/${file}`,\n      mode,\n      autorename: false,\n      mute: true\n    };\n    await request({\n      path: `https://content.dropboxapi.com/2/files/upload?${stringifyParams(params)}`,\n      method: \"POST\",\n      contentType: \"application/octet-stream\",\n      body: data\n    });\n  }\n  \n  async function post(file, data) {\n    try {\n      return await put(file, data, \"add\");\n    } catch (err) {\n      if (err.code === 409 && err.message.includes(\"conflict\")) {\n        err.code = \"EEXIST\";\n      }\n      throw err;\n    }\n  }\n  \n  async function delete_(file) {\n    try {\n      await requestRPC({\n        path: \"files/delete_v2\",\n        body: {\n          path: `/${file}`\n        }\n      });\n    } catch (err) {\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\n        return;\n      }\n      throw err;\n    }\n  }\n}\n\nmodule.exports = createDrive;\n","/* global self */\nconst {createRequest} = require(\"../request\");\n\nfunction createDrive({\n  getAccessToken,\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\n}) {\n  const request = createRequest({fetch, getAccessToken});\n  return {\n    name: \"onedrive\",\n    get,\n    put,\n    post,\n    delete: delete_,\n    list\n  };\n  \n  async function query(args) {\n    args.path = `https://graph.microsoft.com/v1.0/me/drive/special/approot${args.path}`;\n    return await request(args);\n  }\n  \n  async function list(file) {\n    if (file) {\n      file = `:/${file}:`;\n    }\n    let result = await query({\n      path: `${file}/children?select=name`\n    });\n    let files = result.value.map(i => i.name);\n    while (result[\"@odata.nextLink\"]) {\n      result = await request({\n        path: result[\"@odata.nextLink\"]\n      });\n      files = files.concat(result.value.map(i => i.name));\n    }\n    return files;\n  }\n  \n  async function get(file) {\n    return await query({\n      path: `:/${file}:/content`,\n      format: \"text\"\n    });\n  }\n  \n  async function put(file, data) {\n    await query({\n      method: \"PUT\",\n      path: `:/${file}:/content`,\n      headers: {\n        \"Content-Type\": \"text/plain\"\n      },\n      body: data\n    });\n  }\n  \n  async function post(file, data) {\n    try {\n      await query({\n        method: \"PUT\",\n        path: `:/${file}:/content?@microsoft.graph.conflictBehavior=fail`,\n        headers: {\n          \"Content-Type\": \"text/plain\"\n        },\n        body: data\n      });\n    } catch (err) {\n      if (err.code === 409 && err.message.includes(\"nameAlreadyExists\")) {\n        err.code = \"EEXIST\";\n      }\n      throw err;\n    }\n  }\n  \n  async function delete_(file) {\n    try {\n      await query({\n        method: \"DELETE\",\n        path: `:/${file}:`\n      });\n    } catch (err) {\n      if (err.code === 404) {\n        return;\n      }\n      throw err;\n    }\n  }\n}\n\nmodule.exports = createDrive;\n","/* global self */\nconst {createRequest, RequestError} = require(\"../request\");\nconst {LockError} = require(\"../lock\");\n\nfunction createDrive({\n  getAccessToken,\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\n  FormData = (typeof self !== \"undefined\" ? self : global).FormData,\n  Blob = (typeof self !== \"undefined\" ? self : global).Blob\n}) {\n  const request = createRequest({fetch, getAccessToken});\n  const fileMetaCache = new Map;\n  let lockRev;\n  return {\n    name: \"google\",\n    get,\n    put,\n    post,\n    delete: delete_,\n    list,\n    init,\n    acquireLock,\n    releaseLock,\n    fileMetaCache\n  };\n  \n  async function revDelete(fileId, revId) {\n    await request({\n      method: \"DELETE\",\n      path: `https://www.googleapis.com/drive/v3/files/${fileId}/revisions/${revId}`\n    });\n  }\n  \n  async function acquireLock(expire) {\n    const lock = fileMetaCache.get(\"lock.json\");\n    // write the lock to the cloud\n    const {headRevisionId} = await queryPatch(lock.id, JSON.stringify({expire: Date.now() + expire * 60 * 1000}), {keepRevisionForever: true});\n    try {\n      const result = await request({\n        path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions?fields=revisions(id)`\n      });\n      for (let i = 1; i < result.revisions.length; i++) {\n        const revId = result.revisions[i].id;\n        if (revId === headRevisionId) {\n          // success\n          lockRev = headRevisionId;\n          return;\n        }\n        const rev = JSON.parse(await request({\n          path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions/${revId}?alt=media`\n        }));\n        if (rev.expire > Date.now()) {\n          // previous lock is still valid\n          throw new LockError(rev.expire);\n        }\n        // delete outdated lock\n        await revDelete(lock.id, revId);\n      }\n      throw new Error(\"cannot find lock revision\");\n    } catch (err) {\n      // cleanup\n      await revDelete(lock.id, headRevisionId);\n      throw err;\n    }\n  }\n  \n  async function releaseLock() {\n    const lock = fileMetaCache.get(\"lock.json\");\n    await revDelete(lock.id, lockRev);\n    lockRev = null;\n  }\n  \n  async function queryList(path, onPage) {\n    path = \"https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&fields=nextPageToken,files(id,name,headRevisionId)\" + (path ? \"&\" + path : \"\");\n    let result = await request({path});\n    onPage(result);\n    while (result.nextPageToken) {\n      result = await request({path: `${path}&pageToken=${result.nextPageToken}`});\n      onPage(result);\n    }\n  }\n  \n  async function queryPatch(id, text, query) {\n    let path = `https://www.googleapis.com/upload/drive/v3/files/${id}?uploadType=media&fields=headRevisionId`;\n    if (query) {\n      path += `&${new URLSearchParams(query).toString()}`;\n    }\n    return await request({\n      method: \"PATCH\",\n      path,\n      headers: {\n        \"Content-Type\": \"text/plain\"\n      },\n      body: text\n    });\n  }\n  \n  async function updateMeta(query) {\n    if (query) {\n      query = `q=${encodeURIComponent(query)}`;\n    }\n    await queryList(query, result => {\n      for (const file of result.files) {\n        fileMetaCache.set(file.name, file);\n      }\n    });\n  }\n  \n  async function init() {\n    await updateMeta();\n    if (!fileMetaCache.has(\"lock.json\")) {\n      await post(\"lock.json\", \"{}\");\n    }\n    if (!fileMetaCache.has(\"meta.json\")) {\n      await post(\"meta.json\", \"{}\");\n    }\n  }\n  \n  async function list(file) {\n    // FIXME: this only works if file is a single dir\n    // FIXME: this only works if the list method is called right after init, use\n    // queryList instead?\n    return [...fileMetaCache.values()]\n      .filter(f => f.name.startsWith(file + \"/\"))\n      .map(f => f.name.split(\"/\")[1]);\n  }\n  \n  async function get(file) {\n    let meta = fileMetaCache.get(file);\n    if (!meta) {\n      await updateMeta(`name = '${file}'`);\n      meta = fileMetaCache.get(file);\n      if (!meta) {\n        throw new RequestError(`metaCache doesn't contain ${file}`, null, \"ENOENT\");\n      }\n    }\n    try {\n      return await request({\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}?alt=media`\n      });\n    } catch (err) {\n      if (err.code === 404) {\n        err.code = \"ENOENT\";\n      }\n      throw err;\n    }\n  }\n  \n  async function put(file, data) {\n    if (!fileMetaCache.has(file)) {\n      return await post(file, data);\n    }\n    const meta = fileMetaCache.get(file);\n    const result = await queryPatch(meta.id, data);\n    meta.headRevisionId = result.headRevisionId;\n  }\n  \n  async function post(file, data) {\n    const body = new FormData;\n    const meta = {\n      name: file,\n      parents: [\"appDataFolder\"]\n    };\n    body.append(\"metadata\", new Blob([JSON.stringify(meta)], {type: \"application/json; charset=UTF-8\"}));\n    body.append(\"media\", new Blob([data], {type: \"text/plain\"}));\n    const result = await request({\n      method: \"POST\",\n      path: \"https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,headRevisionId\",\n      body\n    });\n    fileMetaCache.set(result.name, result);\n  }\n  \n  async function delete_(file) {\n    const meta = fileMetaCache.get(file);\n    if (!meta) {\n      return;\n    }\n    try {\n      await request({\n        method: \"DELETE\",\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}`\n      });\n    } catch (err) {\n      if (err.code === 404) {\n        return;\n      }\n      throw err;\n    }\n  }\n}\n\nmodule.exports = createDrive;\n","const {createLock} = require(\"@eight04/read-write-lock\");\nconst {LockError} = require(\"./lock\");\nconst {delay, debounced} = require(\"./util\");\n\nfunction buildDrive(_drive) {\n  const drive = Object.create(_drive);\n  drive.get = async path => JSON.parse(await _drive.get(path));\n  drive.put = async (path, data) => await _drive.put(path, JSON.stringify(data));\n  drive.post = async (path, data) => await _drive.post(path, JSON.stringify(data));\n  drive.isInit = false;\n  \n  if (!drive.acquireLock) {\n    drive.acquireLock = acquireLock;\n    drive.releaseLock = releaseLock;\n  }\n  \n  if (!drive.getMeta) {\n    drive.getMeta = getMeta;\n    drive.putMeta = putMeta;\n  }\n  \n  if (!drive.peekChanges) {\n    drive.peekChanges = peekChanges;\n  }\n  \n  return drive;\n  \n  async function acquireLock(expire) {\n    try {\n      await this.post(\"lock.json\", {expire: Date.now() + expire * 60 * 1000});\n    } catch (err) {\n      if (err.code !== \"EEXIST\") {\n        throw err;\n      }\n      const data = await this.get(\"lock.json\");\n      if (Date.now() > data.expire) {\n        // FIXME: this may delete a different lock created by other instances\n        await this.delete(\"lock.json\");\n        throw new Error(\"Found expired lock, please try again\");\n      }\n      throw new LockError(data.expire);\n    }\n  }\n  \n  async function releaseLock() {\n    await this.delete(\"lock.json\");\n  }\n  \n  async function getMeta() {\n    try {\n      return await this.get(\"meta.json\");\n    } catch (err) {\n      if (err.code === \"ENOENT\" || err.code === 404) {\n        return {};\n      }\n      throw err;\n    }\n  }\n  \n  async function putMeta(data) {\n    await this.put(\"meta.json\", data);\n  }\n  \n  async function peekChanges(oldMeta) {\n    const newMeta = await this.getMeta();\n    return newMeta.lastChange !== oldMeta.lastChange;\n  }\n}\n\nfunction dbToCloud({\n  onGet,\n  onPut,\n  onDelete,\n  onFirstSync,\n  onWarn = console.error,\n  onProgress,\n  compareRevision,\n  getState,\n  setState,\n  lockExpire = 60,\n  retryMaxAttempts = 5,\n  retryExp = 1.5,\n  retryDelay = 10\n}) {\n  let drive;\n  let state;\n  let meta;\n  const changeCache = new Map;\n  const saveState = debounced(() => setState(drive, state));\n  const revisionCache = new Map;\n  const lock = createLock();\n  return {\n    use,\n    init,\n    uninit,\n    put,\n    delete: delete_,\n    syncNow,\n    drive: () => drive,\n    isInit: () => Boolean(state && state.enabled)\n  };\n  \n  function use(newDrive) {\n    drive = buildDrive(newDrive);\n  }\n  \n  function init() {\n    return lock.write(async () => {\n      if (state && state.enabled) {\n        return;\n      }\n      if (!drive) {\n        throw new Error(\"cloud drive is undefined\");\n      }\n      \n      state = await getState(drive) || {};\n      state.enabled = true;\n      if (!state.queue) {\n        state.queue = [];\n      }\n    });\n  }\n  \n  function uninit() {\n    return lock.write(async () => {\n      if (!state || !state.enabled) {\n        return;\n      }\n      state = meta = null;\n      changeCache.clear();\n      revisionCache.clear();\n      if (drive.uninit && drive.isInit) {\n        await drive.uninit();\n        drive.isInit = false;\n      }\n      await saveState();\n    });\n  }\n  \n  async function syncPull() {\n    meta = await drive.getMeta();\n    if (!meta.lastChange || meta.lastChange === state.lastChange) {\n      // nothing changes\n      return;\n    }\n    let changes = [];\n    if (!state.lastChange) {\n      // pull everything\n      changes = (await drive.list(\"docs\"))\n        .map(name => ({action: 'put', _id: name.slice(0, -5)}));\n    } else {\n      const end = Math.floor((meta.lastChange - 1) / 100); // inclusive end\n      let i = Math.floor(state.lastChange / 100);\n      while (i <= end) {\n        const newChanges = await drive.get(`changes/${i}.json`);\n        changeCache.set(i, newChanges);\n        changes = changes.concat(newChanges);\n        i++;\n      }\n      changes = changes.slice(state.lastChange % 100);\n    }\n    // merge changes\n    const idx = new Map;\n    for (const change of changes) {\n      idx.set(change._id, change);\n    }\n    let loaded = 0;\n    for (const [id, change] of idx) {\n      let doc, _rev;\n      if (onProgress) {\n        onProgress({\n          phase: 'pull',\n          total: idx.size,\n          loaded,\n          change\n        });\n      }\n      if (change.action === \"delete\") {\n        await onDelete(id, change._rev);\n      } else if (change.action === \"put\") {\n        try {\n          ({doc, _rev} = await drive.get(`docs/${id}.json`));\n        } catch (err) {\n          if (err.code === \"ENOENT\" || err.code === 404) {\n            onWarn(`Cannot find ${id}. Is it deleted without updating the history?`);\n            loaded++;\n            continue;\n          }\n          throw err;\n        }\n        await onPut(doc);\n      }\n      // record the remote revision\n      const rev = change._rev || _rev;\n      if (rev) {\n        revisionCache.set(id, rev);\n      }\n      loaded++;\n    }\n    state.lastChange = meta.lastChange;\n    await saveState();\n  }\n  \n  async function syncPush() {\n    if (!state.queue.length) {\n      // nothing to push\n      return;\n    }\n    // snapshot\n    const changes = state.queue.slice();\n\n    // merge changes\n    const idx = new Map;\n    for (const change of changes) {\n      idx.set(change._id, change);\n    }\n    // drop outdated change\n    const newChanges = [];\n    for (const change of idx.values()) {\n      // FIXME: is it safe to assume that the local doc is newer when\n      // remoteRev is undefined?\n      const remoteRev = revisionCache.get(change._id);\n      if (remoteRev !== undefined && compareRevision(change._rev, remoteRev) <= 0) {\n        continue;\n      }\n      newChanges.push(change);\n    }\n    // FIXME: there should be no need to push data when !newChanges.length\n    \n    // start pushing\n    let loaded = 0;\n    for (const change of newChanges) {\n      if (onProgress) {\n        onProgress({\n          phase: 'push',\n          loaded,\n          total: newChanges.length,\n          change\n        });\n      }\n      if (change.action === \"delete\") {\n        await drive.delete(`docs/${change._id}.json`);\n      } else if (change.action === \"put\") {\n        const doc = await onGet(change._id, change._rev);\n        await drive.put(`docs/${change._id}.json`, {doc, _rev: change._rev});\n      }\n      revisionCache.set(change._id, change._rev);\n      loaded++;\n    }\n    \n    // push changes\n    let lastChanges;\n    let index;\n    // meta is already pulled in syncPull\n    if (meta.lastChange) {\n      index = Math.floor(meta.lastChange / 100);\n      const len = meta.lastChange % 100;\n      lastChanges = len ?\n        changeCache.get(index) || await drive.get(`changes/${index}.json`) :\n        [];\n      // it is possible that JSON data contains more records defined by\n      // meta.lastChange\n      lastChanges = lastChanges.slice(0, len).concat(newChanges);\n    } else {\n      // first sync\n      index = 0;\n      lastChanges = newChanges;\n    }\n    \n    for (let i = 0; i * 100 < lastChanges.length; i++) {\n      const window = lastChanges.slice(i * 100, (i + 1) * 100);\n      await drive.put(`changes/${index + i}.json`, window);\n      changeCache.set(index + i, window);\n    }\n    meta.lastChange = (meta.lastChange || 0) + newChanges.length;\n    await drive.putMeta(meta);\n    \n    state.queue = state.queue.slice(changes.length);\n    state.lastChange = meta.lastChange;\n    await saveState();\n  }\n  \n  async function sync() {\n    let tried = 0;\n    let wait = retryDelay;\n    let lastErr;\n    while (true) { // eslint-disable-line no-constant-condition\n      try {\n        await drive.acquireLock(lockExpire);\n        break;\n      } catch (err) {\n        if (err.name !== \"LockError\") {\n          throw err;\n        }\n        lastErr = err;\n      }\n      tried++;\n      if (tried >= retryMaxAttempts) {\n        throw lastErr;\n      }\n      await delay(wait * 1000);\n      wait *= retryExp;\n    }\n    try {\n      await syncPull();\n      await syncPush();\n    } finally {\n      await drive.releaseLock();\n    }\n  }\n  \n  function syncNow(peek) {\n    return lock.write(async () => {\n      if (!state || !state.enabled) {\n        throw new Error(\"Cannot sync now, the sync is not enabled\");\n      }\n      if (drive.init && !drive.isInit) {\n        await drive.init();\n        drive.isInit = true;\n      }\n      if (state.lastChange == null) {\n        await onFirstSync();\n      }\n      await _syncNow(peek);\n    });\n  }\n  \n  async function _syncNow(peek = true) {\n    if (onProgress) {\n      onProgress({\n        phase: 'start'\n      });\n    }\n    try {\n      if (!state.queue.length && peek && meta) {\n        const changed = await drive.peekChanges(meta);\n        if (!changed) {\n          return;\n        }\n      }\n      await sync();\n    } finally {\n      if (onProgress) {\n        onProgress({\n          phase: 'end'\n        });\n      }\n    }\n  }\n  \n  function put(_id, _rev) {\n    if (!state || !state.enabled) {\n      return;\n    }\n    state.queue.push({\n      _id, _rev, action: \"put\"\n    });\n    saveState();\n  }\n  \n  function delete_(_id, _rev) {\n    if (!state || !state.enabled) {\n      return;\n    }\n    state.queue.push({\n      _id, _rev, action: \"delete\"\n    });\n    saveState();\n  }\n}\n\nmodule.exports = {dbToCloud};\n"],"names":["createLock","maxActiveReader","Infinity","firstTask","lastTask","activeReader","self","read","fn","que","write","length","block","task","prev","next","q","defer","q2","createTask","deque","promise","o","Promise","resolve","reject","result","err","onDone","then","_onDone","pending","afterDone","LockError","Error","constructor","expire","super","concat","Date","toLocaleString","this","name","captureStackTrace","debounced","timer","clearTimeout","setTimeout","run","delay","time","xmlToJSON","node","children","Array","prototype","filter","call","childNodes","i","nodeType","textContent","_step","_iterator","_createForOfIteratorHelper","s","n","done","c","value","cResult","localName","isArray","push","list","e","f","createXMLParser","DOMParser","parser","text","parseFromString","percentToByte","p","String","fromCharCode","parseInt","slice","encode","str","btoa","encodeURIComponent","replace","byteToPercent","b","charCodeAt","toString","decode","decodeURIComponent","from","atob","join","RequestError","message","origin","code","status","createRequest","fetch","cooldown","getAccessToken","username","password","lock","basicAuth","base64","args","_ref","_asyncToGenerator","_x2","_doRequest","apply","arguments","doRequest","method","_x","_ref2","path","contentType","_headers","headers","format","_ref2$raw","raw","_objectWithoutProperties","_excluded","Object","assign","res","_objectSpread","ok","retry","get","Number","resContentType","test","json","dirname","dir","basename","match","arrayify","userAgent","owner","repo","global","request","shaCache","Map","put","post","file","data","delete","_x5","_delete_","_list","requestAPI","names","item","set","sha","_get","content","_x3","_x4","_put","overwrite","params","has","body","JSON","stringify","retried","includes","_x6","_post","_x7","requestRPC","entries","entry","has_more","_step2","_iterator2","cursor","stringifyParams","obj","URLSearchParams","mode","autorename","mute","_x8","query","_query","files","map","Content-Type","FormData","Blob","lockRev","fileMetaCache","_x1","_x10","_x11","_x14","_x0","init","_init","acquireLock","_acquireLock","releaseLock","_releaseLock","revDelete","_revDelete","fileId","revId","headRevisionId","queryPatch","id","now","keepRevisionForever","revisions","rev","parse","queryList","_queryList","onPage","nextPageToken","_queryPatch","updateMeta","_x9","_updateMeta","values","startsWith","split","meta","_x12","_x13","parents","append","type","url","parseXML","endsWith","requestDAV","_requestDAV","error","multistatus","response","r","href","Depth","propstat","some","prop","resourcetype","undefined","collection","base","URL","withDir","_withDir","cb","If-None-Match","onGet","onPut","onDelete","onFirstSync","onWarn","console","onProgress","compareRevision","getState","setState","lockExpire","retryMaxAttempts","retryExp","retryDelay","drive","state","changeCache","saveState","revisionCache","use","newDrive","_drive","create","_ref3","isInit","getMeta","_getMeta","putMeta","_putMeta","peekChanges","_peekChanges","oldMeta","lastChange","buildDrive","enabled","queue","uninit","clear","_id","_rev","action","syncNow","peek","_syncNow2","_syncNow","Boolean","syncPull","_syncPull","changes","end","Math","floor","newChanges","idx","change","loaded","_step2$value","_slicedToArray","doc","phase","total","size","_yield$_drive2$get","syncPush","_syncPush","_step3","_iterator3","_step4","_iterator4","remoteRev","lastChanges","index","_i","_newChanges","len","window","sync","_sync","lastErr","tried","wait"],"mappings":"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"}