{"version":3,"file":"db-to-cloud.min.js","sources":["../node_modules/@eight04/read-write-lock/index.js","../lib/db-to-cloud.js","../node_modules/universal-base64/dist/browser.js","../lib/request.js","../lib/drive/github.js","../lib/drive/dropbox.js","../lib/drive/onedrive.js","../lib/drive/google.js"],"sourcesContent":["function createLock({maxActiveReader = Infinity} = {}) {\r\n  let firstTask;\r\n  let lastTask;\r\n  let activeReader = 0;\r\n  const self = {\r\n    read: fn => que(fn, false),\r\n    write: fn => que(fn, true),\r\n    length: 0\r\n  };\r\n  return self;\r\n  \r\n  function que(fn, block) {\r\n    const task = createTask({fn, block});\r\n    if (!lastTask) {\r\n      firstTask = lastTask = task;\r\n    } else {\r\n      lastTask.next = task;\r\n      task.prev = lastTask;\r\n      lastTask = task;\r\n      if (!firstTask) {\r\n        firstTask = lastTask;\r\n      }\r\n    }\r\n    self.length++;\r\n    deque();\r\n    return task.q.promise;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n  \r\n  function createTask({\r\n    fn,\r\n    block = false,\r\n    prev,\r\n    next,\r\n    q = defer(),\r\n    q2 = fn.length ? defer() : null\r\n  }) {\r\n    return {fn, block, prev, next, q, q2};\r\n  }\r\n  \r\n  function deque() {\r\n    const task = firstTask;\r\n    if (\r\n      !task ||\r\n      task.block && task.prev ||\r\n      task.prev && task.prev.block ||\r\n      activeReader >= maxActiveReader\r\n    ) {\r\n      return;\r\n    }\r\n    if (!task.block) {\r\n      activeReader++;\r\n    }\r\n    firstTask = task.next;\r\n    let result;\r\n    try {\r\n      result = task.fn(task.q2 && task.q2.resolve);\r\n    } catch (err) {\r\n      task.q.reject(err);\r\n      // auto release with sync error\r\n      // q2 is useless in this case\r\n      onDone();\r\n      return;\r\n    }\r\n    if (task.q2) {\r\n      task.q2.promise.then(_onDone);\r\n    }\r\n    if (result && result.then) {\r\n      const pending = result.then(task.q.resolve, task.q.reject);\r\n      if (!task.q2) {\r\n        pending.then(onDone);\r\n      }\r\n    } else {\r\n      task.q.resolve(result);\r\n      if (!task.q2) {\r\n        // it's a sync function and you don't want to release it manually, why\r\n        // do you need a lock?\r\n        onDone();\r\n        return;\r\n      }\r\n    }\r\n    deque();\r\n    \r\n    function onDone() {\r\n      _onDone();\r\n    }\r\n    \r\n    function _onDone(afterDone) {\r\n      if (task.prev) {\r\n        task.prev.next = task.next;\r\n      }\r\n      if (task.next) {\r\n        task.next.prev = task.prev;\r\n      }\r\n      if (lastTask === task) {\r\n        lastTask = task.prev;\r\n      }\r\n      if (!task.block) {\r\n        activeReader--;\r\n      }\r\n      self.length--;\r\n      if (afterDone) {\r\n        afterDone();\r\n      }\r\n      deque();\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLockPool(options) {\r\n  const locks = new Map; // scope -> lock\r\n  return {\r\n    read: (scope, fn) => op(scope, fn, \"read\"),\r\n    write: (scope, fn) => op(scope, fn, \"write\"),\r\n    locks\r\n  };\r\n  \r\n  async function op(scopeIter, fn, opType) {\r\n    // FIXME: dead lock if there are duplicated scopes?\r\n    const scopes = [];\r\n    const acquiring = [];\r\n    for (const scope of scopeIter) {\r\n      let lock = locks.get(scope);\r\n      if (!lock) {\r\n        lock = createLock(options);\r\n        locks.set(scope, lock);\r\n      }\r\n      const o = {\r\n        lock,\r\n        scope,\r\n        relase: null\r\n      };\r\n      acquiring.push(lock[opType](release => {\r\n        o.release = release;\r\n      }));\r\n      scopes.push(o);\r\n    }\r\n    await Promise.all(acquiring);\r\n    let result;\r\n    try {\r\n      result = fn(fn.length && onDone);\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n    if (result && result.then) {\r\n      if (!fn.length) {\r\n        result.then(onDone, onDone);\r\n      }\r\n      return await result;\r\n    }\r\n    if (!fn.length) {\r\n      onDone();\r\n    }\r\n    return result;\r\n    \r\n    function onDone() {\r\n      for (const scope of scopes) {\r\n        scope.release(() => {\r\n          if (!scope.lock.length) {\r\n            locks.delete(scope.scope);\r\n          }\r\n        });\r\n      }\r\n      scopes.length = 0;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  createLock,\r\n  createLockPool\r\n};\r\n","const {createLock} = require(\"@eight04/read-write-lock\");\r\n\r\nfunction debounced(fn) {\r\n  let timer = 0;\r\n  let q;\r\n  return () => {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    timer = setTimeout(run);\r\n    if (!q) {\r\n      q = defer();\r\n    }\r\n    return q.promise;\r\n  };\r\n  \r\n  function run() {\r\n    Promise.resolve(fn())\r\n      .then(q.resolve, q.reject);\r\n    timer = 0;\r\n    q = null;\r\n  }\r\n  \r\n  function defer() {\r\n    const o = {};\r\n    o.promise = new Promise((resolve, reject) => {\r\n      o.resolve = resolve;\r\n      o.reject = reject;\r\n    });\r\n    return o;\r\n  }\r\n}\r\n\r\nfunction buildDrive(_drive) {\r\n  const drive = Object.create(_drive);\r\n  drive.get = async path => JSON.parse(await _drive.get(path));\r\n  drive.put = async (path, data) => await _drive.put(path, JSON.stringify(data));\r\n  drive.post = async (path, data) => await _drive.post(path, JSON.stringify(data));\r\n  \r\n  if (!drive.acquireLock) {\r\n    drive.acquireLock = acquireLock;\r\n    drive.releaseLock = releaseLock;\r\n  }\r\n  \r\n  if (!drive.getMeta) {\r\n    drive.getMeta = getMeta;\r\n    drive.putMeta = putMeta;\r\n  }\r\n  \r\n  if (!drive.peekChanges) {\r\n    drive.peekChanges = peekChanges;\r\n  }\r\n  \r\n  return drive;\r\n  \r\n  async function acquireLock(expire) {\r\n    try {\r\n      await this.post(\"lock.json\", {expire: Date.now() + expire * 60 * 1000});\r\n    } catch (err) {\r\n      if (err.code === \"EEXIST\") {\r\n        const data = await this.get(\"lock.json\");\r\n        if (Date.now() > data.expire) {\r\n          await this.delete(\"lock.json\");\r\n        }\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    await this.delete(\"lock.json\");\r\n  }\r\n  \r\n  async function getMeta() {\r\n    try {\r\n      return await this.get(\"meta.json\");\r\n    } catch (err) {\r\n      if (err.code === \"ENOENT\" || err.code === 404) {\r\n        return {};\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function putMeta(data) {\r\n    await this.put(\"meta.json\", data);\r\n  }\r\n  \r\n  async function peekChanges(oldMeta) {\r\n    const newMeta = await this.getMeta();\r\n    return newMeta.lastChange !== oldMeta.lastChange;\r\n  }\r\n}\r\n\r\nfunction dbToCloud({\r\n  onGet,\r\n  onPut,\r\n  onDelete,\r\n  onFirstSync,\r\n  onWarn = console.error,\r\n  onProgress,\r\n  compareRevision,\r\n  getState,\r\n  setState,\r\n  lockExpire = 60\r\n}) {\r\n  let drive;\r\n  let state;\r\n  let meta;\r\n  const changeCache = new Map;\r\n  const saveState = debounced(() => setState(drive, state));\r\n  const revisionCache = new Map;\r\n  const lock = createLock();\r\n  return {\r\n    use,\r\n    start,\r\n    stop,\r\n    put,\r\n    delete: delete_,\r\n    syncNow,\r\n    drive: () => drive,\r\n    isInit: () => Boolean(state && state.enabled)\r\n  };\r\n  \r\n  function use(newDrive) {\r\n    drive = buildDrive(newDrive);\r\n  }\r\n  \r\n  function start() {\r\n    return lock.write(async () => {\r\n      if (state && state.enabled) {\r\n        return;\r\n      }\r\n      if (!drive) {\r\n        throw new Error(\"cloud drive is undefined\");\r\n      }\r\n      if (drive.init) {\r\n        await drive.init();\r\n      }\r\n      \r\n      state = await getState(drive) || {};\r\n      state.enabled = true;\r\n      if (!state.queue) {\r\n        state.queue = [];\r\n      }\r\n      if (state.lastChange == null) {\r\n        await onFirstSync();\r\n      }\r\n      await _syncNow();\r\n    });\r\n  }\r\n  \r\n  function stop() {\r\n    return lock.write(async () => {\r\n      if (!state || !state.enabled) {\r\n        return;\r\n      }\r\n      state = meta = null;\r\n      changeCache.clear();\r\n      revisionCache.clear();\r\n      if (drive.uninit) {\r\n        await drive.uninit();\r\n      }\r\n      await saveState();\r\n    });\r\n  }\r\n  \r\n  async function syncPull() {\r\n    meta = await drive.getMeta();\r\n    if (!meta.lastChange || meta.lastChange === state.lastChange) {\r\n      // nothing changes\r\n      return;\r\n    }\r\n    let changes = [];\r\n    if (!state.lastChange) {\r\n      // pull everything\r\n      changes = (await drive.list(\"docs\"))\r\n        .map(name => ({action: 'put', _id: name.slice(0, -5)}));\r\n    } else {\r\n      const end = Math.floor((meta.lastChange - 1) / 100); // inclusive end\r\n      let i = Math.floor(state.lastChange / 100);\r\n      while (i <= end) {\r\n        const newChanges = await drive.get(`changes/${i}.json`);\r\n        changeCache.set(i, newChanges);\r\n        changes = changes.concat(newChanges);\r\n        i++;\r\n      }\r\n      changes = changes.slice(state.lastChange % 100);\r\n    }\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    let loaded = 0;\r\n    for (const [id, change] of idx) {\r\n      let doc, _rev;\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'pull',\r\n          total: idx.size,\r\n          loaded,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await onDelete(id, change._rev);\r\n      } else if (change.action === \"put\") {\r\n        try {\r\n          ({doc, _rev} = await drive.get(`docs/${id}.json`));\r\n        } catch (err) {\r\n          if (err.code === \"ENOENT\" || err.code === 404) {\r\n            onWarn(`Cannot find ${id}. Is it deleted without updating the history?`);\r\n            loaded++;\r\n            continue;\r\n          }\r\n          throw err;\r\n        }\r\n        await onPut(doc);\r\n      }\r\n      // record the remote revision\r\n      const rev = change._rev || _rev;\r\n      if (rev) {\r\n        revisionCache.set(id, rev);\r\n      }\r\n      loaded++;\r\n    }\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function syncPush() {\r\n    if (!state.queue.length) {\r\n      // nothing to push\r\n      return;\r\n    }\r\n    // snapshot\r\n    const changes = state.queue.slice();\r\n\r\n    // merge changes\r\n    const idx = new Map;\r\n    for (const change of changes) {\r\n      idx.set(change._id, change);\r\n    }\r\n    // drop outdated change\r\n    const newChanges = [];\r\n    for (const change of idx.values()) {\r\n      // FIXME: is it safe to assume that the local doc is newer when\r\n      // remoteRev is undefined?\r\n      const remoteRev = revisionCache.get(change._id);\r\n      if (remoteRev !== undefined && compareRevision(change._rev, remoteRev) <= 0) {\r\n        continue;\r\n      }\r\n      newChanges.push(change);\r\n    }\r\n    // FIXME: there should be no need to push data when !newChanges.length\r\n    \r\n    // start pushing\r\n    let loaded = 0;\r\n    for (const change of newChanges) {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'push',\r\n          loaded,\r\n          total: newChanges.length,\r\n          change\r\n        });\r\n      }\r\n      if (change.action === \"delete\") {\r\n        await drive.delete(`docs/${change._id}.json`);\r\n      } else if (change.action === \"put\") {\r\n        const doc = await onGet(change._id, change._rev);\r\n        await drive.put(`docs/${change._id}.json`, {doc, _rev: change._rev});\r\n      }\r\n      revisionCache.set(change._id, change._rev);\r\n      loaded++;\r\n    }\r\n    \r\n    // push changes\r\n    let lastChanges;\r\n    let index;\r\n    // meta is already pulled in syncPull\r\n    if (meta.lastChange) {\r\n      index = Math.floor(meta.lastChange / 100);\r\n      const len = meta.lastChange % 100;\r\n      lastChanges = len ?\r\n        changeCache.get(index) || await drive.get(`changes/${index}.json`) :\r\n        [];\r\n      // it is possible that JSON data contains more records defined by\r\n      // meta.lastChange\r\n      lastChanges = lastChanges.slice(0, len).concat(newChanges);\r\n    } else {\r\n      // first sync\r\n      index = 0;\r\n      lastChanges = newChanges;\r\n    }\r\n    \r\n    for (let i = 0; i * 100 < lastChanges.length; i++) {\r\n      const window = lastChanges.slice(i * 100, (i + 1) * 100);\r\n      await drive.put(`changes/${index + i}.json`, window);\r\n      changeCache.set(index + i, window);\r\n    }\r\n    meta.lastChange = (meta.lastChange || 0) + newChanges.length;\r\n    await drive.putMeta(meta);\r\n    \r\n    state.queue = state.queue.slice(changes.length);\r\n    state.lastChange = meta.lastChange;\r\n    await saveState();\r\n  }\r\n  \r\n  async function sync() {\r\n    await drive.acquireLock(lockExpire);\r\n    try {\r\n      await syncPull();\r\n      await syncPush();\r\n    } finally {\r\n      await drive.releaseLock();\r\n    }\r\n  }\r\n  \r\n  function syncNow(peek) {\r\n    return lock.write(async () => {\r\n      if (!state || !state.enabled) {\r\n        throw new Error(\"Cannot sync now, the sync is not enabled\");\r\n      }\r\n      await _syncNow(peek);\r\n    });\r\n  }\r\n  \r\n  async function _syncNow(peek = true) {\r\n    if (onProgress) {\r\n      onProgress({\r\n        phase: 'start'\r\n      });\r\n    }\r\n    try {\r\n      if (!state.queue.length && peek && meta) {\r\n        const changed = await drive.peekChanges(meta);\r\n        if (!changed) {\r\n          return;\r\n        }\r\n      }\r\n      await sync();\r\n    } finally {\r\n      if (onProgress) {\r\n        onProgress({\r\n          phase: 'end'\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  function put(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"put\"\r\n    });\r\n    saveState();\r\n  }\r\n  \r\n  function delete_(_id, _rev) {\r\n    if (!state || !state.enabled) {\r\n      return;\r\n    }\r\n    state.queue.push({\r\n      _id, _rev, action: \"delete\"\r\n    });\r\n    saveState();\r\n  }\r\n}\r\n\r\nmodule.exports = {dbToCloud};\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction percentToByte(p) {\n    return String.fromCharCode(parseInt(p.slice(1), 16));\n}\nfunction encode(str) {\n    return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));\n}\nexports.encode = encode;\nfunction byteToPercent(b) {\n    return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`;\n}\nfunction decode(str) {\n    return decodeURIComponent(Array.from(atob(str), byteToPercent).join(\"\"));\n}\nexports.decode = decode;\n//# sourceMappingURL=browser.js.map","const {createLock} = require(\"@eight04/read-write-lock\");\r\n\r\nclass RequestError extends Error {\r\n  constructor(message, origin, code = origin && origin.status) {\r\n    super(message);\r\n    this.code = code;\r\n    this.origin = origin;\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, RequestError);\r\n    }\r\n  }\r\n}\r\n\r\nfunction delay(time) {\r\n  return new Promise(resolve => setTimeout(resolve, time));\r\n}\r\n\r\nfunction createRequest({fetch, cooldown = 0, getAccessToken}) {\r\n  const lock = createLock();\r\n  return args => {\r\n    return lock.write(async done => {\r\n      try {\r\n        return await doRequest(args);\r\n      } finally {\r\n        if (!cooldown || !args.method || args.method === \"GET\") {\r\n          done();\r\n        } else {\r\n          setTimeout(done, cooldown);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  \r\n  async function doRequest({path, contentType, headers: _headers, format, ...args}) {\r\n    const headers = {\r\n      \"Authorization\": `Bearer ${await getAccessToken()}`\r\n    };\r\n    if (contentType) {\r\n      headers[\"Content-Type\"] = contentType;\r\n    }\r\n    Object.assign(headers, _headers);\r\n    while (true) { // eslint-disable-line no-constant-condition\r\n      const res = await fetch(path, {\r\n        headers,\r\n        ...args\r\n      });\r\n      if (!res.ok) {\r\n        const retry = res.headers.get(\"Retry-After\");\r\n        if (retry) {\r\n          const time = Number(retry);\r\n          if (time) {\r\n            await delay(time * 1000);\r\n            continue;\r\n          }\r\n        }\r\n        const text = await res.text();\r\n        throw new RequestError(`failed to fetch [${res.status}]: ${text}`, res);\r\n      }\r\n      if (format) {\r\n        return await res[format]();\r\n      }\r\n      const resContentType = res.headers.get(\"Content-Type\");\r\n      if (/application\\/json/.test(resContentType)) {\r\n        return await res.json();\r\n      }\r\n      return await res.text();\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {createRequest, RequestError};\r\n","/* global self */\r\nconst base64 = require(\"universal-base64\");\r\n\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  userAgent = \"db-to-cloud\",\r\n  owner,\r\n  repo,\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken, cooldown: 1000});\r\n  const shaCache = new Map;\r\n  return {\r\n    name: \"github\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    shaCache\r\n  };\r\n  \r\n  function requestAPI(args) {\r\n    if (!args.headers) {\r\n      args.headers = {};\r\n    }\r\n    if (!args.headers[\"User-Agent\"]) {\r\n      args.headers[\"User-Agent\"] = userAgent;\r\n    }\r\n    if (!args.headers[\"Accept\"]) {\r\n      args.headers[\"Accept\"] = \"application/vnd.github.v3+json\";\r\n    }\r\n    args.path = `https://api.github.com${args.path}`;\r\n    return request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the Git Trees API.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    const names = [];\r\n    for (const item of result) {\r\n      names.push(item.name);\r\n      shaCache.set(item.path, item.sha);\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  async function get(file) {\r\n    // FIXME: This API supports files up to 1 megabyte in size.\r\n    const result = await requestAPI({\r\n      path: `/repos/${owner}/${repo}/contents/${file}`\r\n    });\r\n    shaCache.set(result.path, result.sha);\r\n    return base64.decode(result.content);\r\n  }\r\n  \r\n  async function put(file, data, overwrite = true) {\r\n    const params = {\r\n      message: \"\",\r\n      content: base64.encode(data)\r\n    };\r\n    if (overwrite && shaCache.has(file)) {\r\n      params.sha = shaCache.get(file);\r\n    }\r\n    const args = {\r\n      method: \"PUT\",\r\n      path: `/repos/${owner}/${repo}/contents/${file}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(params)\r\n    };\r\n    let retried = false;\r\n    let result;\r\n    while (!result) {\r\n      try {\r\n        result = await requestAPI(args);\r\n      } catch (err) {\r\n        if (err.code !== 422 || !err.message.includes(\"\\\\\\\"sha\\\\\\\" wasn't supplied\")) {\r\n          throw err;\r\n        }\r\n        if (!overwrite || retried) {\r\n          err.code = \"EEXIST\";\r\n          throw err;\r\n        }\r\n        await get(file);\r\n      }\r\n      retried = true;\r\n    }\r\n    shaCache.set(file, result.content.sha);\r\n  }\r\n  \r\n  function post(file, data) {\r\n    return put(file, data, false);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      let sha = shaCache.get(file);\r\n      if (!sha) {\r\n        await get(file);\r\n        sha = shaCache.get(file);\r\n      }\r\n      await requestAPI({\r\n        method: \"DELETE\",\r\n        path: `/repos/${owner}/${repo}/contents/${file}`,\r\n        body: JSON.stringify({\r\n          message: \"\",\r\n          sha\r\n        })\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      // FIXME: do we have to handle 422 errors?\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"dropbox\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  function requestRPC({path, body, ...args}) {\r\n    return request({\r\n      method: \"POST\",\r\n      path: `https://api.dropboxapi.com/2/${path}`,\r\n      contentType: \"application/json\",\r\n      body: JSON.stringify(body),\r\n      ...args\r\n    });\r\n  }\r\n  \r\n  async function list(file) {\r\n    const names = [];\r\n    let result = await requestRPC({\r\n      path: \"files/list_folder\",\r\n      body: {\r\n        path: `/${file}`\r\n      }\r\n    });\r\n    for (const entry of result.entries) {\r\n      names.push(entry.name);\r\n    }\r\n    if (!result.has_more) {\r\n      return names;\r\n    }\r\n    while (result.has_more) {\r\n      result = await requestRPC({\r\n        path: \"files/list_folder/continue\",\r\n        body: {\r\n          cursor: result.cursor\r\n        }\r\n      });\r\n      for (const entry of result.entries) {\r\n        names.push(entry.name);\r\n      }\r\n    }\r\n    return names;\r\n  }\r\n  \r\n  function stringifyParams(obj) {\r\n    const params = new URLSearchParams;\r\n    params.set(\"arg\", JSON.stringify(obj));\r\n    return params.toString();\r\n  }\r\n  \r\n  async function get(file) {\r\n    const params = {\r\n      path: `/${file}`\r\n    };\r\n    try {\r\n      return await request({\r\n        path: `https://content.dropboxapi.com/2/files/download?${stringifyParams(params)}`,\r\n        format: \"text\"\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data, mode = \"overwrite\") {\r\n    const params = {\r\n      path: `/${file}`,\r\n      mode,\r\n      autorename: false\r\n    };\r\n    await request({\r\n      path: `https://content.dropboxapi.com/2/files/upload?${stringifyParams(params)}`,\r\n      method: \"POST\",\r\n      contentType: \"application/octet-stream\",\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      return await put(file, data, \"add\");\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"conflict\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await requestRPC({\r\n        path: \"files/delete_v2\",\r\n        body: {\r\n          path: `/${file}`\r\n        }\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"not_found\")) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  return {\r\n    name: \"onedrive\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list\r\n  };\r\n  \r\n  async function query(args) {\r\n    args.path = `https://graph.microsoft.com/v1.0/me/drive/special/approot${args.path}`;\r\n    return await request(args);\r\n  }\r\n  \r\n  async function list(file) {\r\n    if (file) {\r\n      file = `:/${file}:`;\r\n    }\r\n    let result = await query({\r\n      path: `${file}/children?select=name`\r\n    });\r\n    let files = result.value.map(i => i.name);\r\n    while (result[\"@odata.nextLink\"]) {\r\n      result = await request({\r\n        path: result[\"@odata.nextLink\"]\r\n      });\r\n      files = files.concat(result.value.map(i => i.name));\r\n    }\r\n    return files;\r\n  }\r\n  \r\n  async function get(file) {\r\n    return await query({\r\n      path: `:/${file}:/content`,\r\n      format: \"text\"\r\n    });\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    await query({\r\n      method: \"PUT\",\r\n      path: `:/${file}:/content`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: data\r\n    });\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    try {\r\n      await query({\r\n        method: \"PUT\",\r\n        path: `:/${file}:/content?@microsoft.graph.conflictBehavior=fail`,\r\n        headers: {\r\n          \"Content-Type\": \"text/plain\"\r\n        },\r\n        body: data\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 409 && err.message.includes(\"nameAlreadyExists\")) {\r\n        err.code = \"EEXIST\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    try {\r\n      await query({\r\n        method: \"DELETE\",\r\n        path: `:/${file}:`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n","/* global self */\r\nconst {createRequest, RequestError} = require(\"../request\");\r\n\r\nfunction createDrive({\r\n  getAccessToken,\r\n  fetch = (typeof self !== \"undefined\" ? self : global).fetch,\r\n  FormData = (typeof self !== \"undefined\" ? self : global).FormData,\r\n  Blob = (typeof self !== \"undefined\" ? self : global).Blob\r\n}) {\r\n  const request = createRequest({fetch, getAccessToken});\r\n  const fileMetaCache = new Map;\r\n  let lockRev;\r\n  return {\r\n    name: \"google\",\r\n    get,\r\n    put,\r\n    post,\r\n    delete: delete_,\r\n    list,\r\n    init,\r\n    acquireLock,\r\n    releaseLock,\r\n    fileMetaCache\r\n  };\r\n  \r\n  async function revDelete(fileId, revId) {\r\n    await request({\r\n      method: \"DELETE\",\r\n      path: `https://www.googleapis.com/drive/v3/files/${fileId}/revisions/${revId}`\r\n    });\r\n  }\r\n  \r\n  async function acquireLock(expire) {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    const {headRevisionId} = await queryPatch(lock.id, JSON.stringify({expire: Date.now() + expire * 60 * 1000}));\r\n    const result = await request({\r\n      path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions?fields=revisions(id)`\r\n    });\r\n    for (let i = 1; i < result.revisions.length; i++) {\r\n      const revId = result.revisions[i].id;\r\n      if (revId === headRevisionId) {\r\n        // success\r\n        lockRev = headRevisionId;\r\n        return;\r\n      }\r\n      const rev = JSON.parse(await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${lock.id}/revisions/${revId}?alt=media`\r\n      }));\r\n      if (rev.expire > Date.now()) {\r\n        // failed, delete the lock\r\n        await revDelete(lock.id, headRevisionId);\r\n        throw new RequestError(\"failed to acquire lock\", null, \"EEXIST\");\r\n      }\r\n      // delete outdated lock\r\n      await revDelete(lock.id, revId);\r\n    }\r\n    throw new Error(\"cannot find lock revision\");\r\n  }\r\n  \r\n  async function releaseLock() {\r\n    const lock = fileMetaCache.get(\"lock.json\");\r\n    await revDelete(lock.id, lockRev);\r\n    lockRev = null;\r\n  }\r\n  \r\n  async function queryList(path, onPage) {\r\n    path = \"https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&fields=nextPageToken,files(id,name,headRevisionId)\" + (path ? \"&\" + path : \"\");\r\n    let result = await request({path});\r\n    onPage(result);\r\n    while (result.nextPageToken) {\r\n      result = await request({path: `${path}&pageToken=${result.nextPageToken}`});\r\n      onPage(result);\r\n    }\r\n  }\r\n  \r\n  async function queryPatch(id, text) {\r\n    return await request({\r\n      method: \"PATCH\",\r\n      path: `https://www.googleapis.com/upload/drive/v3/files/${id}?uploadType=media&fields=headRevisionId`,\r\n      headers: {\r\n        \"Content-Type\": \"text/plain\"\r\n      },\r\n      body: text\r\n    });\r\n  }\r\n  \r\n  async function updateMeta(query) {\r\n    if (query) {\r\n      query = `q=${encodeURIComponent(query)}`;\r\n    }\r\n    await queryList(query, result => {\r\n      for (const file of result.files) {\r\n        fileMetaCache.set(file.name, file);\r\n      }\r\n    });\r\n  }\r\n  \r\n  async function init() {\r\n    await updateMeta();\r\n    if (!fileMetaCache.has(\"lock.json\")) {\r\n      await post(\"lock.json\", \"{}\");\r\n    }\r\n    if (!fileMetaCache.has(\"meta.json\")) {\r\n      await post(\"meta.json\", \"{}\");\r\n    }\r\n  }\r\n  \r\n  async function list(file) {\r\n    // FIXME: this only works if file is a single dir\r\n    // FIXME: this only works if the list method is called right after init, use\r\n    // queryList instead?\r\n    return [...fileMetaCache.values()]\r\n      .filter(f => f.name.startsWith(file + \"/\"))\r\n      .map(f => f.name.split(\"/\")[1]);\r\n  }\r\n  \r\n  async function get(file) {\r\n    let meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      await updateMeta(`name = '${file}'`);\r\n      meta = fileMetaCache.get(file);\r\n      if (!meta) {\r\n        throw new RequestError(`metaCache doesn't contain ${file}`, null, \"ENOENT\");\r\n      }\r\n    }\r\n    try {\r\n      return await request({\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}?alt=media`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        err.code = \"ENOENT\";\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n  \r\n  async function put(file, data) {\r\n    if (!fileMetaCache.has(file)) {\r\n      return await post(file, data);\r\n    }\r\n    const meta = fileMetaCache.get(file);\r\n    const result = await queryPatch(meta.id, data);\r\n    meta.headRevisionId = result.headRevisionId;\r\n  }\r\n  \r\n  async function post(file, data) {\r\n    const body = new FormData;\r\n    const meta = {\r\n      name: file,\r\n      parents: [\"appDataFolder\"]\r\n    };\r\n    body.append(\"metadata\", new Blob([JSON.stringify(meta)], {type: \"application/json; charset=UTF-8\"}));\r\n    body.append(\"media\", new Blob([data], {type: \"text/plain\"}));\r\n    const result = await request({\r\n      method: \"POST\",\r\n      path: \"https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,headRevisionId\",\r\n      body\r\n    });\r\n    fileMetaCache.set(result.name, result);\r\n  }\r\n  \r\n  async function delete_(file) {\r\n    const meta = fileMetaCache.get(file);\r\n    if (!meta) {\r\n      return;\r\n    }\r\n    try {\r\n      await request({\r\n        method: \"DELETE\",\r\n        path: `https://www.googleapis.com/drive/v3/files/${meta.id}`\r\n      });\r\n    } catch (err) {\r\n      if (err.code === 404) {\r\n        return;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createDrive;\r\n"],"names":["createLock","maxActiveReader","Infinity","firstTask","lastTask","activeReader","self","read","fn","que","write","length","block","task","prev","next","q","defer","q2","createTask","deque","promise","o","Promise","resolve","reject","result","err","onDone","then","_onDone","pending","afterDone","debounced","timer","clearTimeout","setTimeout","run","String","fromCharCode","b","charCodeAt","toString","slice","str","btoa","encodeURIComponent","replace","percentToByte","decodeURIComponent","Array","from","atob","byteToPercent","join","RequestError","Error","constructor","message","origin","code","status","captureStackTrace","this","delay","time","createRequest","fetch","cooldown","getAccessToken","lock","args","done","doRequest","method","path","contentType","_headers","headers","format","Object","assign","res","ok","retry","get","Number","text","resContentType","test","json","userAgent","owner","repo","global","request","shaCache","Map","name","put","post","file","data","delete","list","requestAPI","names","item","push","set","sha","base64","decode","content","overwrite","params","encode","has","body","JSON","stringify","retried","includes","requestRPC","entries","entry","has_more","cursor","stringifyParams","obj","URLSearchParams","mode","autorename","query","files","value","map","i","concat","FormData","Blob","fileMetaCache","lockRev","init","acquireLock","releaseLock","revDelete","fileId","revId","expire","headRevisionId","queryPatch","id","Date","now","revisions","parse","queryList","onPage","nextPageToken","updateMeta","values","filter","f","startsWith","split","meta","parents","append","type","onGet","onPut","onDelete","onFirstSync","onWarn","console","error","onProgress","compareRevision","getState","setState","lockExpire","drive","state","changeCache","saveState","revisionCache","use","newDrive","_drive","create","getMeta","putMeta","peekChanges","oldMeta","lastChange","buildDrive","start","enabled","queue","_syncNow","stop","clear","uninit","_id","_rev","action","syncNow","peek","isInit","Boolean","syncPull","changes","end","Math","floor","newChanges","idx","change","loaded","doc","phase","total","size","rev","syncPush","remoteRev","undefined","lastChanges","index","len","window","sync"],"mappings":"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"}